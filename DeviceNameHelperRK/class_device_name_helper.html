<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DeviceNameHelperRK: DeviceNameHelper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DeviceNameHelperRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">DeviceNameHelper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic base class used by all storage methods.  
 <a href="class_device_name_helper.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_device_name_helper_r_k_8h_source.html">DeviceNameHelperRK.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DeviceNameHelper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_device_name_helper.png" usemap="#DeviceNameHelper_map" alt=""/>
  <map id="DeviceNameHelper_map" name="DeviceNameHelper_map">
<area href="class_device_name_helper_e_e_p_r_o_m.html" title="Version of DeviceNameHelper that stores the name in EEPROM emulation." alt="DeviceNameHelperEEPROM" shape="rect" coords="0,56,182,80"/>
<area href="class_device_name_helper_file.html" title="Store the device name in a file on the flash file system." alt="DeviceNameHelperFile" shape="rect" coords="192,56,374,80"/>
<area href="class_device_name_helper_no_storage.html" title="Version of DeviceNameHelper that stores the name in volatile RAM." alt="DeviceNameHelperNoStorage" shape="rect" coords="384,56,566,80"/>
<area href="class_device_name_helper_retained.html" title="Version of DeviceNameHelper that stores the name in retained RAM." alt="DeviceNameHelperRetained" shape="rect" coords="576,56,758,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d73de1ff33d918731aa9333414e3d4b"><td class="memItemLeft" align="right" valign="top"><a id="a0d73de1ff33d918731aa9333414e3d4b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a0d73de1ff33d918731aa9333414e3d4b">loop</a> ()</td></tr>
<tr class="memdesc:a0d73de1ff33d918731aa9333414e3d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">You must call this from loop on every call to <a class="el" href="class_device_name_helper.html#a0d73de1ff33d918731aa9333414e3d4b" title="You must call this from loop on every call to loop()">loop()</a> <br /></td></tr>
<tr class="separator:a0d73de1ff33d918731aa9333414e3d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ef648860298f6cde587f0667ee115a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a65ef648860298f6cde587f0667ee115a">withNameCallback</a> (std::function&lt; void(const char *)&gt; <a class="el" href="class_device_name_helper.html#abb1e8481b317ed4fe5efc5af9c255f59">nameCallback</a>)</td></tr>
<tr class="memdesc:a65ef648860298f6cde587f0667ee115a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a function to call when the name is known.  <a href="class_device_name_helper.html#a65ef648860298f6cde587f0667ee115a">More...</a><br /></td></tr>
<tr class="separator:a65ef648860298f6cde587f0667ee115a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb23271183c9a4aa6a2286c3c5387d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#acfb23271183c9a4aa6a2286c3c5387d6">withCheckPeriod</a> (std::chrono::seconds <a class="el" href="class_device_name_helper.html#aadd144cff1fb56515f9a009d7bd37c30">checkPeriod</a>)</td></tr>
<tr class="memdesc:acfb23271183c9a4aa6a2286c3c5387d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets.  <a href="class_device_name_helper.html#acfb23271183c9a4aa6a2286c3c5387d6">More...</a><br /></td></tr>
<tr class="separator:acfb23271183c9a4aa6a2286c3c5387d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6f562cf9b26f4272ef1f638c16dd1"><td class="memItemLeft" align="right" valign="top"><a id="a2df6f562cf9b26f4272ef1f638c16dd1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a2df6f562cf9b26f4272ef1f638c16dd1">hasName</a> () const</td></tr>
<tr class="memdesc:a2df6f562cf9b26f4272ef1f638c16dd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the name has been retrived and is non-empty. <br /></td></tr>
<tr class="separator:a2df6f562cf9b26f4272ef1f638c16dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb44b5a9f133529ee00dc645cb6c2bd0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#adb44b5a9f133529ee00dc645cb6c2bd0">getName</a> () const</td></tr>
<tr class="memdesc:adb44b5a9f133529ee00dc645cb6c2bd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the device name as a c-string.  <a href="class_device_name_helper.html#adb44b5a9f133529ee00dc645cb6c2bd0">More...</a><br /></td></tr>
<tr class="separator:adb44b5a9f133529ee00dc645cb6c2bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768eac7a20fa33cc46581d285de2c1d9"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a768eac7a20fa33cc46581d285de2c1d9">getLastNameCheckTime</a> () const</td></tr>
<tr class="memdesc:a768eac7a20fa33cc46581d285de2c1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time the name was last fetched.  <a href="class_device_name_helper.html#a768eac7a20fa33cc46581d285de2c1d9">More...</a><br /></td></tr>
<tr class="separator:a768eac7a20fa33cc46581d285de2c1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3066ecb65a743809fa6764b6a264f94"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#ab3066ecb65a743809fa6764b6a264f94">checkName</a> ()</td></tr>
<tr class="memdesc:ab3066ecb65a743809fa6764b6a264f94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request the name again.  <a href="class_device_name_helper.html#ab3066ecb65a743809fa6764b6a264f94">More...</a><br /></td></tr>
<tr class="separator:ab3066ecb65a743809fa6764b6a264f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad920639049890435953987b28267b36a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#ad920639049890435953987b28267b36a">subscriptionRemoved</a> ()</td></tr>
<tr class="memdesc:ad920639049890435953987b28267b36a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call if you've called Particle.unsubscribe.  <a href="class_device_name_helper.html#ad920639049890435953987b28267b36a">More...</a><br /></td></tr>
<tr class="separator:ad920639049890435953987b28267b36a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a4b02c09b1fcce34b4982c79cb682b037"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a4b02c09b1fcce34b4982c79cb682b037">getInstance</a> ()</td></tr>
<tr class="memdesc:a4b02c09b1fcce34b4982c79cb682b037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special generic instance getter.  <a href="class_device_name_helper.html#a4b02c09b1fcce34b4982c79cb682b037">More...</a><br /></td></tr>
<tr class="separator:a4b02c09b1fcce34b4982c79cb682b037"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a1ca87d67b3b3206e1b6ab4bf85ab22d2"><td class="memItemLeft" align="right" valign="top"><a id="a1ca87d67b3b3206e1b6ab4bf85ab22d2"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a1ca87d67b3b3206e1b6ab4bf85ab22d2">DATA_MAGIC</a> = 0x7787a2f2</td></tr>
<tr class="memdesc:a1ca87d67b3b3206e1b6ab4bf85ab22d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Magic bytes used to detect if EEPROM or retained memory has been initialized. <br /></td></tr>
<tr class="separator:a1ca87d67b3b3206e1b6ab4bf85ab22d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9767ad47a5ea4055867da17140a3fcdb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a9767ad47a5ea4055867da17140a3fcdb">DeviceNameHelper</a> ()</td></tr>
<tr class="memdesc:a9767ad47a5ea4055867da17140a3fcdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor - You never instantiate this class directly.  <a href="class_device_name_helper.html#a9767ad47a5ea4055867da17140a3fcdb">More...</a><br /></td></tr>
<tr class="separator:a9767ad47a5ea4055867da17140a3fcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3dafd966d133630d78519246cb2288"><td class="memItemLeft" align="right" valign="top"><a id="acc3dafd966d133630d78519246cb2288"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#acc3dafd966d133630d78519246cb2288">~DeviceNameHelper</a> ()</td></tr>
<tr class="memdesc:acc3dafd966d133630d78519246cb2288"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a singleton and never deleted. <br /></td></tr>
<tr class="separator:acc3dafd966d133630d78519246cb2288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83586dbf5bfce5ea99808101c44d7ad5"><td class="memItemLeft" align="right" valign="top"><a id="a83586dbf5bfce5ea99808101c44d7ad5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a83586dbf5bfce5ea99808101c44d7ad5">DeviceNameHelper</a> (const <a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp;)=delete</td></tr>
<tr class="memdesc:a83586dbf5bfce5ea99808101c44d7ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:a83586dbf5bfce5ea99808101c44d7ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cb0e5d79647151cc6d2dcd50149565"><td class="memItemLeft" align="right" valign="top"><a id="af6cb0e5d79647151cc6d2dcd50149565"></a>
<a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#af6cb0e5d79647151cc6d2dcd50149565">operator=</a> (const <a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp;)=delete</td></tr>
<tr class="memdesc:af6cb0e5d79647151cc6d2dcd50149565"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:af6cb0e5d79647151cc6d2dcd50149565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3b3562db7c4e6c053f24ddec44c08c2"><td class="memItemLeft" align="right" valign="top"><a id="af3b3562db7c4e6c053f24ddec44c08c2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#af3b3562db7c4e6c053f24ddec44c08c2">commonSetup</a> ()</td></tr>
<tr class="memdesc:af3b3562db7c4e6c053f24ddec44c08c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">All of the storage-method specific setup methods call that at the end. <br /></td></tr>
<tr class="separator:af3b3562db7c4e6c053f24ddec44c08c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f9c36f770aea498a43936d46b85a05"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a70f9c36f770aea498a43936d46b85a05">save</a> ()</td></tr>
<tr class="memdesc:a70f9c36f770aea498a43936d46b85a05"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is called to save the <a class="el" href="struct_device_name_helper_data.html" title="Data typically stored in retained memory or EEPROM to avoid having to fetch the name so often.">DeviceNameHelperData</a>.  <a href="class_device_name_helper.html#a70f9c36f770aea498a43936d46b85a05">More...</a><br /></td></tr>
<tr class="separator:a70f9c36f770aea498a43936d46b85a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5238dfd1910c9feab9cb4cbbfb2f1a63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a5238dfd1910c9feab9cb4cbbfb2f1a63">stateStart</a> ()</td></tr>
<tr class="memdesc:a5238dfd1910c9feab9cb4cbbfb2f1a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">State handler, entry point when starting up.  <a href="class_device_name_helper.html#a5238dfd1910c9feab9cb4cbbfb2f1a63">More...</a><br /></td></tr>
<tr class="separator:a5238dfd1910c9feab9cb4cbbfb2f1a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3261bd8417b85702bef4add108f484c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a3261bd8417b85702bef4add108f484c3">stateSubscribe</a> ()</td></tr>
<tr class="memdesc:a3261bd8417b85702bef4add108f484c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a subscription handler, if necessary.  <a href="class_device_name_helper.html#a3261bd8417b85702bef4add108f484c3">More...</a><br /></td></tr>
<tr class="separator:a3261bd8417b85702bef4add108f484c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386252d3a79011afc4f72307982b670d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a386252d3a79011afc4f72307982b670d">stateWaitConnected</a> ()</td></tr>
<tr class="memdesc:a386252d3a79011afc4f72307982b670d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until Particle.connected() and Time.isValid() are true.  <a href="class_device_name_helper.html#a386252d3a79011afc4f72307982b670d">More...</a><br /></td></tr>
<tr class="separator:a386252d3a79011afc4f72307982b670d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b309f38ca48dfb8a4a48e87c5d5e32b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a0b309f38ca48dfb8a4a48e87c5d5e32b">stateWaitRequest</a> ()</td></tr>
<tr class="memdesc:a0b309f38ca48dfb8a4a48e87c5d5e32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits POST_CONNECT_WAIT_MS milliseconds (2 seconds) then publishes the request for device name event "particle/device/name".  <a href="class_device_name_helper.html#a0b309f38ca48dfb8a4a48e87c5d5e32b">More...</a><br /></td></tr>
<tr class="separator:a0b309f38ca48dfb8a4a48e87c5d5e32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5622dda3ffb4a3f31f71d020213440a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#ad5622dda3ffb4a3f31f71d020213440a">stateWaitResponse</a> ()</td></tr>
<tr class="memdesc:ad5622dda3ffb4a3f31f71d020213440a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits for a device name event to be received.  <a href="class_device_name_helper.html#ad5622dda3ffb4a3f31f71d020213440a">More...</a><br /></td></tr>
<tr class="separator:ad5622dda3ffb4a3f31f71d020213440a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c4c7565870387982d4d5e5813bafbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a68c4c7565870387982d4d5e5813bafbe">stateWaitRetry</a> ()</td></tr>
<tr class="memdesc:a68c4c7565870387982d4d5e5813bafbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits 5 minutes (RETRY_WAIT_MS) and tries requesting the name again.  <a href="class_device_name_helper.html#a68c4c7565870387982d4d5e5813bafbe">More...</a><br /></td></tr>
<tr class="separator:a68c4c7565870387982d4d5e5813bafbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a5ba32e632e074022f6641b3f4102ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a5a5ba32e632e074022f6641b3f4102ae">stateWaitRecheck</a> ()</td></tr>
<tr class="memdesc:a5a5ba32e632e074022f6641b3f4102ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait until it's time to check the name again.  <a href="class_device_name_helper.html#a5a5ba32e632e074022f6641b3f4102ae">More...</a><br /></td></tr>
<tr class="separator:a5a5ba32e632e074022f6641b3f4102ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5706cda7c2218a538bcd994c092c7576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a5706cda7c2218a538bcd994c092c7576">subscriptionHandler</a> (const char *eventName, const char *eventData)</td></tr>
<tr class="memdesc:a5706cda7c2218a538bcd994c092c7576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subscription handler for the "particle/device/name" event.  <a href="class_device_name_helper.html#a5706cda7c2218a538bcd994c092c7576">More...</a><br /></td></tr>
<tr class="separator:a5706cda7c2218a538bcd994c092c7576"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa050d29a004d381d81e253799e138685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_device_name_helper_data.html">DeviceNameHelperData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#aa050d29a004d381d81e253799e138685">data</a> = 0</td></tr>
<tr class="memdesc:aa050d29a004d381d81e253799e138685"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="struct_device_name_helper_data.html" title="Data typically stored in retained memory or EEPROM to avoid having to fetch the name so often.">DeviceNameHelperData</a> structure pointer.  <a href="class_device_name_helper.html#aa050d29a004d381d81e253799e138685">More...</a><br /></td></tr>
<tr class="separator:aa050d29a004d381d81e253799e138685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd144cff1fb56515f9a009d7bd37c30"><td class="memItemLeft" align="right" valign="top"><a id="aadd144cff1fb56515f9a009d7bd37c30"></a>
std::chrono::seconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#aadd144cff1fb56515f9a009d7bd37c30">checkPeriod</a> = 0s</td></tr>
<tr class="memdesc:aadd144cff1fb56515f9a009d7bd37c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">How often to fetch the name again in seconds (0 = never check again) <br /></td></tr>
<tr class="separator:aadd144cff1fb56515f9a009d7bd37c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb1e8481b317ed4fe5efc5af9c255f59"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const char *)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#abb1e8481b317ed4fe5efc5af9c255f59">nameCallback</a> = 0</td></tr>
<tr class="memdesc:abb1e8481b317ed4fe5efc5af9c255f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional function or C++11 lambda to call when the name is known.  <a href="class_device_name_helper.html#abb1e8481b317ed4fe5efc5af9c255f59">More...</a><br /></td></tr>
<tr class="separator:abb1e8481b317ed4fe5efc5af9c255f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1844ab6138a56a15a32a06160e37153"><td class="memItemLeft" align="right" valign="top"><a id="af1844ab6138a56a15a32a06160e37153"></a>
std::function&lt; void(<a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#af1844ab6138a56a15a32a06160e37153">stateHandler</a> = 0</td></tr>
<tr class="memdesc:af1844ab6138a56a15a32a06160e37153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current state handler, or NULL if in done state. <br /></td></tr>
<tr class="separator:af1844ab6138a56a15a32a06160e37153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ce0fcaec398dede606b1925df411b2"><td class="memItemLeft" align="right" valign="top"><a id="af9ce0fcaec398dede606b1925df411b2"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#af9ce0fcaec398dede606b1925df411b2">stateTime</a> = 0</td></tr>
<tr class="memdesc:af9ce0fcaec398dede606b1925df411b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some states use this for timing. It's a value from millis() if used. <br /></td></tr>
<tr class="separator:af9ce0fcaec398dede606b1925df411b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accba8f666f7fc9b5f40963a023da6737"><td class="memItemLeft" align="right" valign="top"><a id="accba8f666f7fc9b5f40963a023da6737"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#accba8f666f7fc9b5f40963a023da6737">hasSubscribed</a> = false</td></tr>
<tr class="memdesc:accba8f666f7fc9b5f40963a023da6737"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if Particle.subscribe has been called <br /></td></tr>
<tr class="separator:accba8f666f7fc9b5f40963a023da6737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a38d724caa238da1f42281d1d5d2d4"><td class="memItemLeft" align="right" valign="top"><a id="a66a38d724caa238da1f42281d1d5d2d4"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a66a38d724caa238da1f42281d1d5d2d4">gotResponse</a> = false</td></tr>
<tr class="memdesc:a66a38d724caa238da1f42281d1d5d2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the event subscription handler was called. The name is stored in data.name. <br /></td></tr>
<tr class="separator:a66a38d724caa238da1f42281d1d5d2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af583de83e84d9506afd9e5ce16cd49b2"><td class="memItemLeft" align="right" valign="top"><a id="af583de83e84d9506afd9e5ce16cd49b2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#af583de83e84d9506afd9e5ce16cd49b2">forceCheck</a> = false</td></tr>
<tr class="memdesc:af583de83e84d9506afd9e5ce16cd49b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used by <a class="el" href="class_device_name_helper.html#ab3066ecb65a743809fa6764b6a264f94" title="Request the name again.">checkName()</a> to force the name to be checked again. <br /></td></tr>
<tr class="separator:af583de83e84d9506afd9e5ce16cd49b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a800bdf866ec060fc9024d3e7807517b9"><td class="memItemLeft" align="right" valign="top"><a id="a800bdf866ec060fc9024d3e7807517b9"></a>
static const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a800bdf866ec060fc9024d3e7807517b9">POST_CONNECT_WAIT_MS</a> = 2000</td></tr>
<tr class="memdesc:a800bdf866ec060fc9024d3e7807517b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Amount of time to wait after connection for the subscription to be activated (milliseconds) <br /></td></tr>
<tr class="separator:a800bdf866ec060fc9024d3e7807517b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af49f9183573ce2970cf1fbc9848c58ad"><td class="memItemLeft" align="right" valign="top"><a id="af49f9183573ce2970cf1fbc9848c58ad"></a>
static const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#af49f9183573ce2970cf1fbc9848c58ad">RESPONSE_WAIT_MS</a> = 15000</td></tr>
<tr class="memdesc:af49f9183573ce2970cf1fbc9848c58ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">How long to wait for a device name response before timing out and waiting to retry (milliseconds) <br /></td></tr>
<tr class="separator:af49f9183573ce2970cf1fbc9848c58ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ff75698ed96ce928ebd6be57744bc4"><td class="memItemLeft" align="right" valign="top"><a id="a01ff75698ed96ce928ebd6be57744bc4"></a>
static const unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#a01ff75698ed96ce928ebd6be57744bc4">RETRY_WAIT_MS</a> = 5 * 60 * 1000</td></tr>
<tr class="memdesc:a01ff75698ed96ce928ebd6be57744bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">How long to wait to retry a request to get the device name (in milliseconds) <br /></td></tr>
<tr class="separator:a01ff75698ed96ce928ebd6be57744bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44174f4abce2c37da38c90c12847c79"><td class="memItemLeft" align="right" valign="top"><a id="ad44174f4abce2c37da38c90c12847c79"></a>
static <a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_device_name_helper.html#ad44174f4abce2c37da38c90c12847c79">_instance</a> = 0</td></tr>
<tr class="memdesc:ad44174f4abce2c37da38c90c12847c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton instance pointer, set by the subclass instance() methods. <br /></td></tr>
<tr class="separator:ad44174f4abce2c37da38c90c12847c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic base class used by all storage methods. </p>
<p>You can't instantiate one of these, you need to instantiate a specific subclass such as <a class="el" href="class_device_name_helper_e_e_p_r_o_m.html" title="Version of DeviceNameHelper that stores the name in EEPROM emulation.">DeviceNameHelperEEPROM</a>, <a class="el" href="class_device_name_helper_retained.html" title="Version of DeviceNameHelper that stores the name in retained RAM.">DeviceNameHelperRetained</a>, or <a class="el" href="class_device_name_helper_no_storage.html" title="Version of DeviceNameHelper that stores the name in volatile RAM.">DeviceNameHelperNoStorage</a>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9767ad47a5ea4055867da17140a3fcdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9767ad47a5ea4055867da17140a3fcdb">&#9670;&nbsp;</a></span>DeviceNameHelper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DeviceNameHelper::DeviceNameHelper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor - You never instantiate this class directly. </p>
<p>Instead, get a singleton instance of a subclass by using <a class="el" href="class_device_name_helper_retained.html#adef9d79cbc2f054e0c0111cbdbbdb322" title="Get the singleton instance of this class, creating it if necessary.">DeviceNameHelperRetained::instance()</a>, <a class="el" href="class_device_name_helper_e_e_p_r_o_m.html#a9a8414bb21785eb559cca27252202837" title="Get the singleton instance of this class, creating it if necessary.">DeviceNameHelperEEPROM.instance()</a>, <a class="el" href="class_device_name_helper_no_storage.html#ae79ff351f2d3e4493dc0803c4d0a1fe6" title="Get the singleton instance of this class, creating it if necessary.">DeviceNameHelperNoStorage::instance()</a>, or <a class="el" href="class_device_name_helper_file.html#a8fb8f1b2dfd47365094a11e0302fe05e" title="Get the singleton instance of this class, creating it if necessary.">DeviceNameHelperFile::instance()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3066ecb65a743809fa6764b6a264f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3066ecb65a743809fa6764b6a264f94">&#9670;&nbsp;</a></span>checkName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::checkName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request the name again. </p>
<p>This overrides the periodic check period and requests the name to be checked now, even if it's known and it's not time to check. </p>

</div>
</div>
<a id="a4b02c09b1fcce34b4982c79cb682b037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b02c09b1fcce34b4982c79cb682b037">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_device_name_helper.html">DeviceNameHelper</a>* DeviceNameHelper::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special generic instance getter. </p>
<dl class="section return"><dt>Returns</dt><dd>A DeviceNameHelper*, or NULL if it hasn't been instantiated yet.</dd></dl>
<p>Normally you use a specific instance getter like <a class="el" href="class_device_name_helper_e_e_p_r_o_m.html#a9a8414bb21785eb559cca27252202837" title="Get the singleton instance of this class, creating it if necessary.">DeviceNameHelperEEPROM::instance()</a> which will create the singleton instance if it has not been instantiated yet.</p>
<p>In some rare cases, you may want to get the generic instance pointer, if an instance has been created. You'd typically do this if you wanted to get the name if <a class="el" href="class_device_name_helper_no_storage.html" title="Version of DeviceNameHelper that stores the name in volatile RAM.">DeviceNameHelperNoStorage</a> has been set up, without having to know which storage method was used.</p>
<p>Note that this method will not instantiate the singleton if it does not exist since it doesn't know which one you want. Thus it returns a pointer to the object not a reference, so it can return NULL if the instance does not exist yet. </p>

</div>
</div>
<a id="a768eac7a20fa33cc46581d285de2c1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768eac7a20fa33cc46581d285de2c1d9">&#9670;&nbsp;</a></span>getLastNameCheckTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">long DeviceNameHelper::getLastNameCheckTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the time the name was last fetched. </p>
<p>Value is from from Time.now(), seconds past January 1, 1970, UTC. </p>

</div>
</div>
<a id="adb44b5a9f133529ee00dc645cb6c2bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb44b5a9f133529ee00dc645cb6c2bd0">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* DeviceNameHelper::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the device name as a c-string. </p>
<p>May return an empty string if the name has not been retrieved yet </p>

</div>
</div>
<a id="a70f9c36f770aea498a43936d46b85a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f9c36f770aea498a43936d46b85a05">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::save </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is called to save the <a class="el" href="struct_device_name_helper_data.html" title="Data typically stored in retained memory or EEPROM to avoid having to fetch the name so often.">DeviceNameHelperData</a>. </p>
<p>This is called always. This base class does nothing. The <a class="el" href="class_device_name_helper_e_e_p_r_o_m.html" title="Version of DeviceNameHelper that stores the name in EEPROM emulation.">DeviceNameHelperEEPROM</a> and <a class="el" href="class_device_name_helper_file.html" title="Store the device name in a file on the flash file system.">DeviceNameHelperFile</a> subclasses override this to save the data. </p>

<p>Reimplemented in <a class="el" href="class_device_name_helper_file.html#a76e2cadfc12827c4c316e84affa9367c">DeviceNameHelperFile</a>, and <a class="el" href="class_device_name_helper_e_e_p_r_o_m.html#ad64a1b5eeb4b099402a1254b1da8f018">DeviceNameHelperEEPROM</a>.</p>

</div>
</div>
<a id="a5238dfd1910c9feab9cb4cbbfb2f1a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5238dfd1910c9feab9cb4cbbfb2f1a63">&#9670;&nbsp;</a></span>stateStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>State handler, entry point when starting up. </p>
<p>If the device name is saved, this will return quickly without enabling the device name subscription handler.</p>
<p>Next state: stateWaitRecheck - If the device name is set stateSubscribe - If the device name needs to be retrieved </p>

</div>
</div>
<a id="a3261bd8417b85702bef4add108f484c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3261bd8417b85702bef4add108f484c3">&#9670;&nbsp;</a></span>stateSubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateSubscribe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a subscription handler, if necessary. </p>
<p>Next state: stateWaitConnected </p>

</div>
</div>
<a id="a386252d3a79011afc4f72307982b670d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386252d3a79011afc4f72307982b670d">&#9670;&nbsp;</a></span>stateWaitConnected()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateWaitConnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits until Particle.connected() and Time.isValid() are true. </p>
<p>Next state: stateWaitRequest </p>

</div>
</div>
<a id="a5a5ba32e632e074022f6641b3f4102ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a5ba32e632e074022f6641b3f4102ae">&#9670;&nbsp;</a></span>stateWaitRecheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateWaitRecheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait until it's time to check the name again. </p>
<p>Next state: stateSubscribe if it's time to check the name again NULL if we're done </p>

</div>
</div>
<a id="a0b309f38ca48dfb8a4a48e87c5d5e32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b309f38ca48dfb8a4a48e87c5d5e32b">&#9670;&nbsp;</a></span>stateWaitRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateWaitRequest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits POST_CONNECT_WAIT_MS milliseconds (2 seconds) then publishes the request for device name event "particle/device/name". </p>
<p>Next state: stateWaitResponse </p>

</div>
</div>
<a id="ad5622dda3ffb4a3f31f71d020213440a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5622dda3ffb4a3f31f71d020213440a">&#9670;&nbsp;</a></span>stateWaitResponse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateWaitResponse </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits for a device name event to be received. </p>
<p>If the name is received, it is saved (if necessary) and the name callback is called (if present).</p>
<p>Next state: stateWaitRecheck - name was found stateWaitRetry - timeout (RESPONSE_WAIT_MS, 15 seconds) or empty name </p>

</div>
</div>
<a id="a68c4c7565870387982d4d5e5813bafbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c4c7565870387982d4d5e5813bafbe">&#9670;&nbsp;</a></span>stateWaitRetry()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::stateWaitRetry </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Waits 5 minutes (RETRY_WAIT_MS) and tries requesting the name again. </p>
<p>Next state: stateWaitConnected </p>

</div>
</div>
<a id="a5706cda7c2218a538bcd994c092c7576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5706cda7c2218a538bcd994c092c7576">&#9670;&nbsp;</a></span>subscriptionHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::subscriptionHandler </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eventData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subscription handler for the "particle/device/name" event. </p>
<p>Since there's no way to unsubscribe a single subscription handler, it's never removed. See <a class="el" href="class_device_name_helper.html#ad920639049890435953987b28267b36a" title="Call if you&#39;ve called Particle.unsubscribe.">subscriptionRemoved()</a> if you call Particle.unsubscribe() from your code (which is rare). </p>

</div>
</div>
<a id="ad920639049890435953987b28267b36a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad920639049890435953987b28267b36a">&#9670;&nbsp;</a></span>subscriptionRemoved()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DeviceNameHelper::subscriptionRemoved </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call if you've called Particle.unsubscribe. </p>
<p>There is no function to remove a single subscription handler; Particle.unsubscribe unsubscribes all handlers. Also, there is no way to tell if a subscription handler has been added when using a C++ class as the handler. Thus we use a flag to keep track if whether we've subscribed or not.</p>
<p>But if you call Particle.unsubscribe() the flag could be set but the subscription would no longer exist, so the subscription wouldn't work and the device name could not be retrieved.</p>
<p>This function is used to rectify this rare condition. </p>

</div>
</div>
<a id="acfb23271183c9a4aa6a2286c3c5387d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb23271183c9a4aa6a2286c3c5387d6">&#9670;&nbsp;</a></span>withCheckPeriod()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_device_name_helper.html">DeviceNameHelper</a>&amp; DeviceNameHelper::withCheckPeriod </td>
          <td>(</td>
          <td class="paramtype">std::chrono::seconds&#160;</td>
          <td class="paramname"><em>checkPeriod</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">checkPeriod</td><td>How often to check. You can use chrono literals such as 24h for to check once a day, for example.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this, so you can chain the withXXX() calls, fluent-style.</dd></dl>
<p>The default is to check once. After the name has been retrieved it will not be retrieved again. This also means that if the name is ever changed, the change would not be detected. </p>

</div>
</div>
<a id="a65ef648860298f6cde587f0667ee115a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ef648860298f6cde587f0667ee115a">&#9670;&nbsp;</a></span>withNameCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_device_name_helper.html">DeviceNameHelper</a> &amp; DeviceNameHelper::withNameCallback </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const char *)&gt;&#160;</td>
          <td class="paramname"><em>nameCallback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a function to call when the name is known. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nameCallback</td><td>The function to call. It can be a C++11 lambda.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this, so you can chain the withXXX() calls, fluent-style.</dd></dl>
<p>The name callback function has the prototype:</p>
<p>void callback(const char *name)</p>
<p>The name is the device name, as a c-string (null terminated). </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="aa050d29a004d381d81e253799e138685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa050d29a004d381d81e253799e138685">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_device_name_helper_data.html">DeviceNameHelperData</a>* DeviceNameHelper::data = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="struct_device_name_helper_data.html" title="Data typically stored in retained memory or EEPROM to avoid having to fetch the name so often.">DeviceNameHelperData</a> structure pointer. </p>
<p>For <a class="el" href="class_device_name_helper_retained.html" title="Version of DeviceNameHelper that stores the name in retained RAM.">DeviceNameHelperRetained</a>, this points to the actual retained memory. For all other storage members, it points to a class member variable for the singleton instance. </p>

</div>
</div>
<a id="abb1e8481b317ed4fe5efc5af9c255f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb1e8481b317ed4fe5efc5af9c255f59">&#9670;&nbsp;</a></span>nameCallback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const char *)&gt; DeviceNameHelper::nameCallback = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optional function or C++11 lambda to call when the name is known. </p>
<p>This can occur during setup() if the name is saved, otherwise it will occur later, after connecting to the cloud. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_device_name_helper_r_k_8h_source.html">DeviceNameHelperRK.h</a></li>
<li>src/DeviceNameHelperRK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
