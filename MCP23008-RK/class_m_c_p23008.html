<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MCP23008-RK: MCP23008 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MCP23008-RK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">MCP23008 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> I2C GPIO chip.  
 <a href="class_m_c_p23008.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_m_c_p23008-_r_k_8h_source.html">MCP23008-RK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc5daf9290ceef13b4d124bb0138cd2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#afc5daf9290ceef13b4d124bb0138cd2e">MCP23008</a> (TwoWire &amp;<a class="el" href="class_m_c_p23008.html#acd8ab4b892d7b7de10f5fd6dfe860295">wire</a>, int <a class="el" href="class_m_c_p23008.html#a4bfe2298280b73edd7f4a61ae0f23b06">addr</a>=0)</td></tr>
<tr class="memdesc:afc5daf9290ceef13b4d124bb0138cd2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the object. Normally you create these as global variables in the main app.  <a href="class_m_c_p23008.html#afc5daf9290ceef13b4d124bb0138cd2e">More...</a><br /></td></tr>
<tr class="separator:afc5daf9290ceef13b4d124bb0138cd2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37bfbfe3abb452a722d356df1fc0a1ae"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a37bfbfe3abb452a722d356df1fc0a1ae">~MCP23008</a> ()</td></tr>
<tr class="memdesc:a37bfbfe3abb452a722d356df1fc0a1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object destructor.  <a href="class_m_c_p23008.html#a37bfbfe3abb452a722d356df1fc0a1ae">More...</a><br /></td></tr>
<tr class="separator:a37bfbfe3abb452a722d356df1fc0a1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f69c68354e5b736d4c99ac2e909aa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ac1f69c68354e5b736d4c99ac2e909aa3">begin</a> (bool callWireBegin=true)</td></tr>
<tr class="memdesc:ac1f69c68354e5b736d4c99ac2e909aa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the library - required from setup()!  <a href="class_m_c_p23008.html#ac1f69c68354e5b736d4c99ac2e909aa3">More...</a><br /></td></tr>
<tr class="separator:ac1f69c68354e5b736d4c99ac2e909aa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb86e518d331539f0b0fdb18411358b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#afb86e518d331539f0b0fdb18411358b0">pinMode</a> (uint16_t pin, PinMode mode)</td></tr>
<tr class="memdesc:afb86e518d331539f0b0fdb18411358b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> GPIO pin mode.  <a href="class_m_c_p23008.html#afb86e518d331539f0b0fdb18411358b0">More...</a><br /></td></tr>
<tr class="separator:afb86e518d331539f0b0fdb18411358b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84c888c07c58f3fd419c86d734c5f38"><td class="memItemLeft" align="right" valign="top">PinMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ab84c888c07c58f3fd419c86d734c5f38">getPinMode</a> (uint16_t pin)</td></tr>
<tr class="memdesc:ab84c888c07c58f3fd419c86d734c5f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently set pin mode.  <a href="class_m_c_p23008.html#ab84c888c07c58f3fd419c86d734c5f38">More...</a><br /></td></tr>
<tr class="separator:ab84c888c07c58f3fd419c86d734c5f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e771f4477fdd7079990c1ffce144945"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a9e771f4477fdd7079990c1ffce144945">pinAvailable</a> (uint16_t pin) const</td></tr>
<tr class="memdesc:a9e771f4477fdd7079990c1ffce144945"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the pin exists on the device.  <a href="class_m_c_p23008.html#a9e771f4477fdd7079990c1ffce144945">More...</a><br /></td></tr>
<tr class="separator:a9e771f4477fdd7079990c1ffce144945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070725da03655925fa6d559abe05f4ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a070725da03655925fa6d559abe05f4ab">digitalWrite</a> (uint16_t pin, uint8_t value)</td></tr>
<tr class="memdesc:a070725da03655925fa6d559abe05f4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the output value of the pin.  <a href="class_m_c_p23008.html#a070725da03655925fa6d559abe05f4ab">More...</a><br /></td></tr>
<tr class="separator:a070725da03655925fa6d559abe05f4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3604eac549c5590f55fe6de7756c862"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ab3604eac549c5590f55fe6de7756c862">digitalRead</a> (uint16_t pin)</td></tr>
<tr class="memdesc:ab3604eac549c5590f55fe6de7756c862"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the input value of a pin.  <a href="class_m_c_p23008.html#ab3604eac549c5590f55fe6de7756c862">More...</a><br /></td></tr>
<tr class="separator:ab3604eac549c5590f55fe6de7756c862"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575096c9ee0813ea83739fac174b4856"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a575096c9ee0813ea83739fac174b4856">readAllPins</a> ()</td></tr>
<tr class="memdesc:a575096c9ee0813ea83739fac174b4856"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads all of the pins at once.  <a href="class_m_c_p23008.html#a575096c9ee0813ea83739fac174b4856">More...</a><br /></td></tr>
<tr class="separator:a575096c9ee0813ea83739fac174b4856"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42bb3eda6d39d42ce312de5b04efb1ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed">enableInterrupts</a> (pin_t <a class="el" href="class_m_c_p23008.html#a39eb7f35fa4bb97c75269f3ff3187741">mcuInterruptPin</a>, MCP23008InterruptOutputType outputType)</td></tr>
<tr class="memdesc:a42bb3eda6d39d42ce312de5b04efb1ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> interrupt mode.  <a href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed">More...</a><br /></td></tr>
<tr class="separator:a42bb3eda6d39d42ce312de5b04efb1ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5a863cb4450c1249d45f77af8eebfdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb">attachInterrupt</a> (uint16_t pin, InterruptMode mode, std::function&lt; void(bool)&gt; handler)</td></tr>
<tr class="memdesc:ae5a863cb4450c1249d45f77af8eebfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an interrupt handler for a pin.  <a href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb">More...</a><br /></td></tr>
<tr class="separator:ae5a863cb4450c1249d45f77af8eebfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c32b713de953b0d1d1206310ec33fa"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a81c32b713de953b0d1d1206310ec33fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a81c32b713de953b0d1d1206310ec33fa">attachInterrupt</a> (uint16_t pin, InterruptMode mode, void(T::*callback)(bool), T *instance)</td></tr>
<tr class="memdesc:a81c32b713de953b0d1d1206310ec33fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attaches an interupt handler in a class member function to a pin.  <a href="class_m_c_p23008.html#a81c32b713de953b0d1d1206310ec33fa">More...</a><br /></td></tr>
<tr class="separator:a81c32b713de953b0d1d1206310ec33fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf8b10a33c1aa31ca2464eb217de75ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#adf8b10a33c1aa31ca2464eb217de75ef">detachInterrupt</a> (uint16_t pin)</td></tr>
<tr class="memdesc:adf8b10a33c1aa31ca2464eb217de75ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Detaches an interrupt handler for a pin.  <a href="class_m_c_p23008.html#adf8b10a33c1aa31ca2464eb217de75ef">More...</a><br /></td></tr>
<tr class="separator:adf8b10a33c1aa31ca2464eb217de75ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab12092de931e6369a2914916dfac3537"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_m_c_p23008.html">MCP23008</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ab12092de931e6369a2914916dfac3537">withStackSize</a> (size_t value)</td></tr>
<tr class="memdesc:ab12092de931e6369a2914916dfac3537"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the stack size of the interrupt handler worker thread.  <a href="class_m_c_p23008.html#ab12092de931e6369a2914916dfac3537">More...</a><br /></td></tr>
<tr class="separator:ab12092de931e6369a2914916dfac3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acacb18b232f395744421ff343c834b32"><td class="memItemLeft" align="right" valign="top"><a id="acacb18b232f395744421ff343c834b32"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#acacb18b232f395744421ff343c834b32">MCP23008</a> (const <a class="el" href="class_m_c_p23008.html">MCP23008</a> &amp;)=delete</td></tr>
<tr class="memdesc:acacb18b232f395744421ff343c834b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:acacb18b232f395744421ff343c834b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc59a068aa41c49bde5de3b96c9cd3e9"><td class="memItemLeft" align="right" valign="top"><a id="adc59a068aa41c49bde5de3b96c9cd3e9"></a>
<a class="el" href="class_m_c_p23008.html">MCP23008</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#adc59a068aa41c49bde5de3b96c9cd3e9">operator=</a> (const <a class="el" href="class_m_c_p23008.html">MCP23008</a> &amp;)=delete</td></tr>
<tr class="memdesc:adc59a068aa41c49bde5de3b96c9cd3e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is not copyable. <br /></td></tr>
<tr class="separator:adc59a068aa41c49bde5de3b96c9cd3e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbe7af5cf34651f28e6dbff2cede5040"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#acbe7af5cf34651f28e6dbff2cede5040">readRegisterPin</a> (uint8_t reg, uint16_t pin)</td></tr>
<tr class="memdesc:acbe7af5cf34651f28e6dbff2cede5040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register and masks off a specific bit.  <a href="class_m_c_p23008.html#acbe7af5cf34651f28e6dbff2cede5040">More...</a><br /></td></tr>
<tr class="separator:acbe7af5cf34651f28e6dbff2cede5040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f79acc17160392cdf52f73b24a5a4bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a8f79acc17160392cdf52f73b24a5a4bb">writeRegisterPin</a> (uint8_t reg, uint16_t pin, bool value)</td></tr>
<tr class="memdesc:a8f79acc17160392cdf52f73b24a5a4bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register, masks off a specific bit, and writes the register back.  <a href="class_m_c_p23008.html#a8f79acc17160392cdf52f73b24a5a4bb">More...</a><br /></td></tr>
<tr class="separator:a8f79acc17160392cdf52f73b24a5a4bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7d79f3a3bbec799ef5876d858dacbb"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a2d7d79f3a3bbec799ef5876d858dacbb">readRegister</a> (uint8_t reg)</td></tr>
<tr class="memdesc:a2d7d79f3a3bbec799ef5876d858dacbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register.  <a href="class_m_c_p23008.html#a2d7d79f3a3bbec799ef5876d858dacbb">More...</a><br /></td></tr>
<tr class="separator:a2d7d79f3a3bbec799ef5876d858dacbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d8b5af1eafb4243cd13200993724fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a52d8b5af1eafb4243cd13200993724fe">writeRegister</a> (uint8_t reg, uint8_t value)</td></tr>
<tr class="memdesc:a52d8b5af1eafb4243cd13200993724fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register.  <a href="class_m_c_p23008.html#a52d8b5af1eafb4243cd13200993724fe">More...</a><br /></td></tr>
<tr class="separator:a52d8b5af1eafb4243cd13200993724fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac750ccc8975257c48ddc11cea33e865b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ac750ccc8975257c48ddc11cea33e865b">handleInterrupts</a> ()</td></tr>
<tr class="memdesc:ac750ccc8975257c48ddc11cea33e865b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handles interrupts, used internally.  <a href="class_m_c_p23008.html#ac750ccc8975257c48ddc11cea33e865b">More...</a><br /></td></tr>
<tr class="separator:ac750ccc8975257c48ddc11cea33e865b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a4dd3ba6a3fe5e694d88f12f3c29094e5"><td class="memItemLeft" align="right" valign="top">static os_thread_return_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a4dd3ba6a3fe5e694d88f12f3c29094e5">threadFunctionStatic</a> (void *param)</td></tr>
<tr class="memdesc:a4dd3ba6a3fe5e694d88f12f3c29094e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Thread function, used internally.  <a href="class_m_c_p23008.html#a4dd3ba6a3fe5e694d88f12f3c29094e5">More...</a><br /></td></tr>
<tr class="separator:a4dd3ba6a3fe5e694d88f12f3c29094e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a39eb7f35fa4bb97c75269f3ff3187741"><td class="memItemLeft" align="right" valign="top">pin_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a39eb7f35fa4bb97c75269f3ff3187741">mcuInterruptPin</a> = PIN_INVALID</td></tr>
<tr class="memdesc:a39eb7f35fa4bb97c75269f3ff3187741"><td class="mdescLeft">&#160;</td><td class="mdescRight">The MCU GPIO the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> INT pin is connected to.  <a href="class_m_c_p23008.html#a39eb7f35fa4bb97c75269f3ff3187741">More...</a><br /></td></tr>
<tr class="separator:a39eb7f35fa4bb97c75269f3ff3187741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d9bce4d7bfe4f1b388cfe46fab0a18e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_m_c_p23008_interrupt_handler.html">MCP23008InterruptHandler</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a5d9bce4d7bfe4f1b388cfe46fab0a18e">interruptHandlers</a></td></tr>
<tr class="memdesc:a5d9bce4d7bfe4f1b388cfe46fab0a18e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of interrupt handlers.  <a href="class_m_c_p23008.html#a5d9bce4d7bfe4f1b388cfe46fab0a18e">More...</a><br /></td></tr>
<tr class="separator:a5d9bce4d7bfe4f1b388cfe46fab0a18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49807c0f884a0fcc990315759313b33"><td class="memItemLeft" align="right" valign="top">os_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ac49807c0f884a0fcc990315759313b33">handlersMutex</a> = 0</td></tr>
<tr class="memdesc:ac49807c0f884a0fcc990315759313b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex used to prevent simultaneous use of interruptHandlers.  <a href="class_m_c_p23008.html#ac49807c0f884a0fcc990315759313b33">More...</a><br /></td></tr>
<tr class="separator:ac49807c0f884a0fcc990315759313b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd8ab4b892d7b7de10f5fd6dfe860295"><td class="memItemLeft" align="right" valign="top"><a id="acd8ab4b892d7b7de10f5fd6dfe860295"></a>
TwoWire &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#acd8ab4b892d7b7de10f5fd6dfe860295">wire</a></td></tr>
<tr class="memdesc:acd8ab4b892d7b7de10f5fd6dfe860295"><td class="mdescLeft">&#160;</td><td class="mdescRight">The I2C interface to use, typically <code>Wire</code> <br /></td></tr>
<tr class="separator:acd8ab4b892d7b7de10f5fd6dfe860295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfe2298280b73edd7f4a61ae0f23b06"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a4bfe2298280b73edd7f4a61ae0f23b06">addr</a></td></tr>
<tr class="memdesc:a4bfe2298280b73edd7f4a61ae0f23b06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> to use (0-7) based on A0, A1, and A2 on the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a>.  <a href="class_m_c_p23008.html#a4bfe2298280b73edd7f4a61ae0f23b06">More...</a><br /></td></tr>
<tr class="separator:a4bfe2298280b73edd7f4a61ae0f23b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af128c623e67255371b9cf86309d007a6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#af128c623e67255371b9cf86309d007a6">stackSize</a> = 1024</td></tr>
<tr class="memdesc:af128c623e67255371b9cf86309d007a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stack size for the worker thread.  <a href="class_m_c_p23008.html#af128c623e67255371b9cf86309d007a6">More...</a><br /></td></tr>
<tr class="separator:af128c623e67255371b9cf86309d007a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:aa0dbf818db23160733008f8dc3216f4c"><td class="memItemLeft" align="right" valign="top"><a id="aa0dbf818db23160733008f8dc3216f4c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#aa0dbf818db23160733008f8dc3216f4c">PIN_0</a> = 0b00000001</td></tr>
<tr class="memdesc:aa0dbf818db23160733008f8dc3216f4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP0 <br /></td></tr>
<tr class="separator:aa0dbf818db23160733008f8dc3216f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49826dc55ab1fb796a5d518cdd0d499f"><td class="memItemLeft" align="right" valign="top"><a id="a49826dc55ab1fb796a5d518cdd0d499f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a49826dc55ab1fb796a5d518cdd0d499f">PIN_1</a> = 0b00000010</td></tr>
<tr class="memdesc:a49826dc55ab1fb796a5d518cdd0d499f"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP1 <br /></td></tr>
<tr class="separator:a49826dc55ab1fb796a5d518cdd0d499f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f782135f815f2e87917d7fc54078cf4"><td class="memItemLeft" align="right" valign="top"><a id="a2f782135f815f2e87917d7fc54078cf4"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a2f782135f815f2e87917d7fc54078cf4">PIN_2</a> = 0b00000100</td></tr>
<tr class="memdesc:a2f782135f815f2e87917d7fc54078cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP2 <br /></td></tr>
<tr class="separator:a2f782135f815f2e87917d7fc54078cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c0d82e26aa71184a8d50f6b24883ff"><td class="memItemLeft" align="right" valign="top"><a id="a59c0d82e26aa71184a8d50f6b24883ff"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a59c0d82e26aa71184a8d50f6b24883ff">PIN_3</a> = 0b00001000</td></tr>
<tr class="memdesc:a59c0d82e26aa71184a8d50f6b24883ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP3 <br /></td></tr>
<tr class="separator:a59c0d82e26aa71184a8d50f6b24883ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e5eae94bacfc0fb13d8a58c8c7ee82"><td class="memItemLeft" align="right" valign="top"><a id="a80e5eae94bacfc0fb13d8a58c8c7ee82"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a80e5eae94bacfc0fb13d8a58c8c7ee82">PIN_4</a> = 0b00010000</td></tr>
<tr class="memdesc:a80e5eae94bacfc0fb13d8a58c8c7ee82"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP4 <br /></td></tr>
<tr class="separator:a80e5eae94bacfc0fb13d8a58c8c7ee82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2501bf2e9814f7bc753d3324695bdc0"><td class="memItemLeft" align="right" valign="top"><a id="af2501bf2e9814f7bc753d3324695bdc0"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#af2501bf2e9814f7bc753d3324695bdc0">PIN_5</a> = 0b00100000</td></tr>
<tr class="memdesc:af2501bf2e9814f7bc753d3324695bdc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP5 <br /></td></tr>
<tr class="separator:af2501bf2e9814f7bc753d3324695bdc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c48d8350c5cc0fa3146d861beb08177"><td class="memItemLeft" align="right" valign="top"><a id="a0c48d8350c5cc0fa3146d861beb08177"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a0c48d8350c5cc0fa3146d861beb08177">PIN_6</a> = 0b01000000</td></tr>
<tr class="memdesc:a0c48d8350c5cc0fa3146d861beb08177"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP6 <br /></td></tr>
<tr class="separator:a0c48d8350c5cc0fa3146d861beb08177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c345f345f973767c3f88f84cc184b2e"><td class="memItemLeft" align="right" valign="top"><a id="a9c345f345f973767c3f88f84cc184b2e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a9c345f345f973767c3f88f84cc184b2e">PIN_7</a> = 0b10000000</td></tr>
<tr class="memdesc:a9c345f345f973767c3f88f84cc184b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">bit mask for GP7 <br /></td></tr>
<tr class="separator:a9c345f345f973767c3f88f84cc184b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33d9dde871b56b1c469c33c35d11c857"><td class="memItemLeft" align="right" valign="top"><a id="a33d9dde871b56b1c469c33c35d11c857"></a>
static const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a33d9dde871b56b1c469c33c35d11c857">NUM_PINS</a> = 8</td></tr>
<tr class="memdesc:a33d9dde871b56b1c469c33c35d11c857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of GP pins on the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> (8) <br /></td></tr>
<tr class="separator:a33d9dde871b56b1c469c33c35d11c857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1286d54e40e049c64dcfc4effc83a7e1"><td class="memItemLeft" align="right" valign="top"><a id="a1286d54e40e049c64dcfc4effc83a7e1"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a1286d54e40e049c64dcfc4effc83a7e1">REG_IODIR</a> = 0x0</td></tr>
<tr class="memdesc:a1286d54e40e049c64dcfc4effc83a7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for IODIR. <br /></td></tr>
<tr class="separator:a1286d54e40e049c64dcfc4effc83a7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ab126c22599b98a7ea333756a5c25"><td class="memItemLeft" align="right" valign="top"><a id="a038ab126c22599b98a7ea333756a5c25"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a038ab126c22599b98a7ea333756a5c25">REG_IPOL</a> = 0x1</td></tr>
<tr class="memdesc:a038ab126c22599b98a7ea333756a5c25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for IPOL. <br /></td></tr>
<tr class="separator:a038ab126c22599b98a7ea333756a5c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45ad378ac07a4d6f85b41fb4e1450bd"><td class="memItemLeft" align="right" valign="top"><a id="ad45ad378ac07a4d6f85b41fb4e1450bd"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#ad45ad378ac07a4d6f85b41fb4e1450bd">REG_GPINTEN</a> = 0x2</td></tr>
<tr class="memdesc:ad45ad378ac07a4d6f85b41fb4e1450bd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for GPINTEN. <br /></td></tr>
<tr class="separator:ad45ad378ac07a4d6f85b41fb4e1450bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2984fb3f217c3ac81c6f71e45d3faa2"><td class="memItemLeft" align="right" valign="top"><a id="aa2984fb3f217c3ac81c6f71e45d3faa2"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#aa2984fb3f217c3ac81c6f71e45d3faa2">REG_DEFVAL</a> = 0x3</td></tr>
<tr class="memdesc:aa2984fb3f217c3ac81c6f71e45d3faa2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for DEFVAL. <br /></td></tr>
<tr class="separator:aa2984fb3f217c3ac81c6f71e45d3faa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ef38d5c0b05e0092386ee8b3c36573"><td class="memItemLeft" align="right" valign="top"><a id="a04ef38d5c0b05e0092386ee8b3c36573"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a04ef38d5c0b05e0092386ee8b3c36573">REG_INTCON</a> = 0x4</td></tr>
<tr class="memdesc:a04ef38d5c0b05e0092386ee8b3c36573"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for INTCON. <br /></td></tr>
<tr class="separator:a04ef38d5c0b05e0092386ee8b3c36573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016c32935affb4d8b649212d1d025f6d"><td class="memItemLeft" align="right" valign="top"><a id="a016c32935affb4d8b649212d1d025f6d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a016c32935affb4d8b649212d1d025f6d">REG_IOCON</a> = 0x5</td></tr>
<tr class="memdesc:a016c32935affb4d8b649212d1d025f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for IOCON. <br /></td></tr>
<tr class="separator:a016c32935affb4d8b649212d1d025f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1b287ca7552503ad2cb4cb4583956d"><td class="memItemLeft" align="right" valign="top"><a id="aed1b287ca7552503ad2cb4cb4583956d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#aed1b287ca7552503ad2cb4cb4583956d">REG_GPPU</a> = 0x6</td></tr>
<tr class="memdesc:aed1b287ca7552503ad2cb4cb4583956d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for GPPU. <br /></td></tr>
<tr class="separator:aed1b287ca7552503ad2cb4cb4583956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf196dba7e3821fe263710d82ed96dc5"><td class="memItemLeft" align="right" valign="top"><a id="aaf196dba7e3821fe263710d82ed96dc5"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#aaf196dba7e3821fe263710d82ed96dc5">REG_INTF</a> = 0x7</td></tr>
<tr class="memdesc:aaf196dba7e3821fe263710d82ed96dc5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for INTF. <br /></td></tr>
<tr class="separator:aaf196dba7e3821fe263710d82ed96dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf176cb6d147154231abaaf75aac1eb"><td class="memItemLeft" align="right" valign="top"><a id="afcf176cb6d147154231abaaf75aac1eb"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#afcf176cb6d147154231abaaf75aac1eb">REG_INTCAP</a> = 0x8</td></tr>
<tr class="memdesc:afcf176cb6d147154231abaaf75aac1eb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for INTCAP. <br /></td></tr>
<tr class="separator:afcf176cb6d147154231abaaf75aac1eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a526e7989757cab159a1ed9a12866a8c9"><td class="memItemLeft" align="right" valign="top"><a id="a526e7989757cab159a1ed9a12866a8c9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a526e7989757cab159a1ed9a12866a8c9">REG_GPIO</a> = 0x9</td></tr>
<tr class="memdesc:a526e7989757cab159a1ed9a12866a8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for GPIO. <br /></td></tr>
<tr class="separator:a526e7989757cab159a1ed9a12866a8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c4c5fc039f854a3e40bc6d6677d58b"><td class="memItemLeft" align="right" valign="top"><a id="a26c4c5fc039f854a3e40bc6d6677d58b"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a26c4c5fc039f854a3e40bc6d6677d58b">REG_OLAT</a> = 0xa</td></tr>
<tr class="memdesc:a26c4c5fc039f854a3e40bc6d6677d58b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register number for OLAT. <br /></td></tr>
<tr class="separator:a26c4c5fc039f854a3e40bc6d6677d58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c80db62fee13b27e78dbcb179642660"><td class="memItemLeft" align="right" valign="top"><a id="a1c80db62fee13b27e78dbcb179642660"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a1c80db62fee13b27e78dbcb179642660">DEVICE_ADDR</a> = 0b0100000</td></tr>
<tr class="memdesc:a1c80db62fee13b27e78dbcb179642660"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base I2C address for the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> (0x20) <br /></td></tr>
<tr class="separator:a1c80db62fee13b27e78dbcb179642660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce7445e2315b619d316999a0dc56baf"><td class="memItemLeft" align="right" valign="top">static Thread *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a9ce7445e2315b619d316999a0dc56baf">thread</a></td></tr>
<tr class="memdesc:a9ce7445e2315b619d316999a0dc56baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">The worker thread object.  <a href="class_m_c_p23008.html#a9ce7445e2315b619d316999a0dc56baf">More...</a><br /></td></tr>
<tr class="separator:a9ce7445e2315b619d316999a0dc56baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3638c276cc6697d949860de42d4bbb13"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; <a class="el" href="class_m_c_p23008.html">MCP23008</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p23008.html#a3638c276cc6697d949860de42d4bbb13">instances</a></td></tr>
<tr class="memdesc:a3638c276cc6697d949860de42d4bbb13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> object instances.  <a href="class_m_c_p23008.html#a3638c276cc6697d949860de42d4bbb13">More...</a><br /></td></tr>
<tr class="separator:a3638c276cc6697d949860de42d4bbb13"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> I2C GPIO chip. </p>
<p>You can connect up to 8 of these to a single I2C interface. You normally create one of these objects for each chip (at a different I2C address) as a global variable in the main application.</p>
<p>You must call <a class="el" href="class_m_c_p23008.html#ac1f69c68354e5b736d4c99ac2e909aa3" title="Initialize the library - required from setup()!">begin()</a> from global setup() before using other library methods! </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afc5daf9290ceef13b4d124bb0138cd2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5daf9290ceef13b4d124bb0138cd2e">&#9670;&nbsp;</a></span>MCP23008()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MCP23008::MCP23008 </td>
          <td>(</td>
          <td class="paramtype">TwoWire &amp;&#160;</td>
          <td class="paramname"><em>wire</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>addr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the object. Normally you create these as global variables in the main app. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wire</td><td>The I2C interface to connect to. This is typically <code>Wire</code> (pins D0 and D1) but could be <code>Wire1</code> on the Electron and E Series, or <code>Wire3</code> on the Tracker SoM.</td></tr>
    <tr><td class="paramname">addr</td><td>the I2C address (0-7) the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> is configured for using the AD0, AD1, and AD2 pins. Note that this is just the 0-7 part, the actual I2C address will be 0x20 - 0x27. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37bfbfe3abb452a722d356df1fc0a1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bfbfe3abb452a722d356df1fc0a1ae">&#9670;&nbsp;</a></span>~MCP23008()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">MCP23008::~MCP23008 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Object destructor. </p>
<p>As this object is normally allocated as a global variable, it will typically never be destructed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae5a863cb4450c1249d45f77af8eebfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a863cb4450c1249d45f77af8eebfdb">&#9670;&nbsp;</a></span>attachInterrupt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::attachInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(bool)&gt;&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attaches an interrupt handler for a pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
    <tr><td class="paramname">mode</td><td>The interrupt handler mode, one of: <code>RISING</code>, <code>FALLING</code>, or <code>CHANGE</code>.</td></tr>
    <tr><td class="paramname">handler</td><td>A function or C++11 lambda with the following prototype:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> handlerFunction(<span class="keywordtype">bool</span> newState);</div>
</div><!-- fragment --><p>You must call <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a> before making this call!</p>
<p>Note that the handler will be called from a thread, not an ISR, so it's not a true interrupt handler. The reason is that in order to handle the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> interrupt, more than one I2C transaction is required. This cannot be easily done at ISR time because an I2C lock needs to be acquired. It can, however, be easily done from a thread, which is what is done here. <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a> starts this thread.</p>
<p>Even though handler is called from a thread and not an ISR you should still avoid any lengthy operations during it, as the thread handles all interrupts on all <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> and blocking it will prevent all other interrupts from being handled.</p>
<p>There is also a version of this method that takes a class member function below.</p>
<p>If you need to pass additional data ("context") you should instead use a C++11 lambda.</p>
<p>You must not call <a class="el" href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb" title="Attaches an interrupt handler for a pin.">attachInterrupt()</a> from an interrupt handler! If you do so, this function will deadlock the thread and all interrupt-related functions will stop working. </p>

</div>
</div>
<a id="a81c32b713de953b0d1d1206310ec33fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c32b713de953b0d1d1206310ec33fa">&#9670;&nbsp;</a></span>attachInterrupt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::attachInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterruptMode&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(bool)&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Attaches an interupt handler in a class member function to a pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
    <tr><td class="paramname">mode</td><td>The interrupt handler mode, one of: <code>RISING</code>, <code>FALLING</code>, or <code>CHANGE</code>.</td></tr>
    <tr><td class="paramname">callback</td><td>A C++ class member function with following prototype:</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyClass::handler(<span class="keywordtype">bool</span> newState);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">instance</td><td>The C++ object instance ("this") pointer.</td></tr>
  </table>
  </dd>
</dl>
<p>You typically use it like this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb">attachInterrupt</a>(2, FALLING, &amp;MyClass::handler, <span class="keyword">this</span>);</div>
</div><!-- fragment --><p>You must call <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a> before making this call!</p>
<p>Note that the handler will be called from a thread, not an ISR, so it's not a true interrupt handler. The reason is that in order to handle the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> interrupt, more than one I2C transaction is required. This cannot be easily done at ISR time because an I2C lock needs to be acquired. It can, however, be easily done from a thread, which is what is done here. <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a> starts this thread.</p>
<p>Even though handler is called from a thread and not an ISR you should still avoid any lengthy operations during it, as the thread handles all interrupts on all <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> and blocking it will prevent all other interrupts from being handled.</p>
<p>There is also a version of this method that takes a class member function below.</p>
<p>If you need to pass additional data ("context") you should instead use a C++11 lambda.</p>
<p>You must not call <a class="el" href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb" title="Attaches an interrupt handler for a pin.">attachInterrupt()</a> from an interrupt handler! If you do so, this function will deadlock the thread and all interrupt-related functions will stop working. <br  />
 </p>

</div>
</div>
<a id="ac1f69c68354e5b736d4c99ac2e909aa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f69c68354e5b736d4c99ac2e909aa3">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::begin </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callWireBegin</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the library - required from setup()! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callWireBegin</td><td>Default is true, to call wire.begin() in this method.</td></tr>
  </table>
  </dd>
</dl>
<p>You must call this from setup() to initialize the hardware. You must not call this from a global object constructor. </p>

</div>
</div>
<a id="adf8b10a33c1aa31ca2464eb217de75ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf8b10a33c1aa31ca2464eb217de75ef">&#9670;&nbsp;</a></span>detachInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::detachInterrupt </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Detaches an interrupt handler for a pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
  </table>
  </dd>
</dl>
<p>You must not call <a class="el" href="class_m_c_p23008.html#adf8b10a33c1aa31ca2464eb217de75ef" title="Detaches an interrupt handler for a pin.">detachInterrupt()</a> from your interrupt handler! If you do so, this function will deadlock the thread and all interrupt-related functions will stop working.</p>
<p>You should avoid attaching and detaching an interrupt excessively as it's a relatively expensive operation. You should only attach and detach from loop(). </p>

</div>
</div>
<a id="ab3604eac549c5590f55fe6de7756c862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3604eac549c5590f55fe6de7756c862">&#9670;&nbsp;</a></span>digitalRead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t MCP23008::digitalRead </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the input value of a pin. </p>
<dl class="section return"><dt>Returns</dt><dd>The value, 0 or 1:</dd></dl>
<ul>
<li>0, false, or LOW</li>
<li>1, true, or HIGH</li>
</ul>
<p>This performs and I2C transaction, so it will be slower that MCU native digitalRead. </p>

</div>
</div>
<a id="a070725da03655925fa6d559abe05f4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070725da03655925fa6d559abe05f4ab">&#9670;&nbsp;</a></span>digitalWrite()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::digitalWrite </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the output value of the pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
    <tr><td class="paramname">value</td><td>The value to set the pin to. Typically you use one of:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li>0, false, or LOW</li>
<li>1, true, or HIGH</li>
</ul>
<p>You must have previously set the pin to OUTPUT mode before using this method.</p>
<p>This performs and I2C transaction, so it will be slower that MCU native digitalWrite. </p>

</div>
</div>
<a id="a42bb3eda6d39d42ce312de5b04efb1ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42bb3eda6d39d42ce312de5b04efb1ed">&#9670;&nbsp;</a></span>enableInterrupts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::enableInterrupts </td>
          <td>(</td>
          <td class="paramtype">pin_t&#160;</td>
          <td class="paramname"><em>mcuInterruptPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MCP23008InterruptOutputType&#160;</td>
          <td class="paramname"><em>outputType</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> interrupt mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mcuInterruptPin</td><td>The MCU pin (D2, A2, etc.) the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> INT pin is connected to. This can also be <code>PIN_INVALID</code> if you want to use the latching change mode but do not have the INT pin connected or do not have a spare MCU GPIO.</td></tr>
    <tr><td class="paramname">outputType</td><td>The way the INT pin is connected. See MCP23008InterruptOutputType.</td></tr>
  </table>
  </dd>
</dl>
<p>Interrupt mode uses the INT output of the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> to connect to a MCU GPIO pin. This allows a change (RISING, FALLING, or CHANGE) on one or more GPIO connected to the expander to trigger the INT line. This is advantageous because the MCU can poll the INT line much more efficiently than making an I2C transaction to poll the interrupt register on the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a>.</p>
<p>Note that this is done from a thread, not using an MCU hardware interrupt. This is because the I2C transaction requires getting a lock on the Wire object, which cannot be done from an ISR. Also, because the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> INT output is latching, there is no danger of missing it when polling.</p>
<p>It's possible for multiple <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> to share a single MCU interrupt line by using open-drain mode to logically OR them together with no external gate required. You can also use separate MCU interrupt lines, if you prefer.</p>
<p>If you pass <code>PIN_INVALID</code> for mcuInterruptPin, outputType is ignored. This mode is used when you still want to be able to handle latching RISING, FALLING, or CHANGE handlers but do not have the INT pin connected or do not have spare MCU GPIOs. This requires an I2C transaction on every thread timeslice (once per millisecond) so it's not as efficient as using a MCU interrupt pin, but this mode is supported. </p>

</div>
</div>
<a id="ab84c888c07c58f3fd419c86d734c5f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84c888c07c58f3fd419c86d734c5f38">&#9670;&nbsp;</a></span>getPinMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PinMode MCP23008::getPinMode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the currently set pin mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>One of these constants:</dd></dl>
<ul>
<li><code>INPUT</code></li>
<li><code>INPUT_PULLUP</code></li>
<li><code>OUTPUT</code> </li>
</ul>

</div>
</div>
<a id="ac750ccc8975257c48ddc11cea33e865b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac750ccc8975257c48ddc11cea33e865b">&#9670;&nbsp;</a></span>handleInterrupts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::handleInterrupts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handles interrupts, used internally. </p>
<p>This method is called from the worker thread when the MCU interrupt GPIO line signals an interrupt. It then queries the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> by I2C to read the interrupt status and call any handlers for pins that caused interrupt(s). </p>

</div>
</div>
<a id="a9e771f4477fdd7079990c1ffce144945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e771f4477fdd7079990c1ffce144945">&#9670;&nbsp;</a></span>pinAvailable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MCP23008::pinAvailable </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the pin exists on the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if pin is 0 &lt;= pin &lt; 8, otherwise false </dd></dl>

</div>
</div>
<a id="afb86e518d331539f0b0fdb18411358b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb86e518d331539f0b0fdb18411358b0">&#9670;&nbsp;</a></span>pinMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MCP23008::pinMode </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PinMode&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> GPIO pin mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The GPIO pin 0 - 7.</td></tr>
    <tr><td class="paramname">mode</td><td>The mode, one of the following:</td></tr>
  </table>
  </dd>
</dl>
<ul>
<li><code>INPUT</code></li>
<li><code>INPUT_PULLUP</code></li>
<li><code>OUTPUT</code></li>
</ul>
<p>Note that the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> does not support input with pull-down or open-drain outputs for its GPIO. </p>

</div>
</div>
<a id="a575096c9ee0813ea83739fac174b4856"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575096c9ee0813ea83739fac174b4856">&#9670;&nbsp;</a></span>readAllPins()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCP23008::readAllPins </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads all of the pins at once. </p>
<dl class="section return"><dt>Returns</dt><dd>A bit mask of the pin values</dd></dl>
<p>The bit mask is as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Pin </th><th class="markdownTableHeadLeft">Mask  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">0 </td><td class="markdownTableBodyLeft">0b00000001 = 0x01  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">1 </td><td class="markdownTableBodyLeft">0b00000010 = 0x02  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">2 </td><td class="markdownTableBodyLeft">0b00000100 = 0x04  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">3 </td><td class="markdownTableBodyLeft">0b00001000 = 0x08  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">4 </td><td class="markdownTableBodyLeft">0b00010000 = 0x10  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">5 </td><td class="markdownTableBodyLeft">0b00100000 = 0x20  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter">6 </td><td class="markdownTableBodyLeft">0b01000000 = 0x40  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter">7 </td><td class="markdownTableBodyLeft">0b10000000 = 0x80  </td></tr>
</table>
<p>In other words: <code>bitMask = (1 &lt;&lt; pin)</code>.</p>
<p>This performs and I2C transaction, but all pins are read with a single I2C transaction so it is faster than calling <a class="el" href="class_m_c_p23008.html#ab3604eac549c5590f55fe6de7756c862" title="Reads the input value of a pin.">digitalRead()</a> multiple times. </p>

</div>
</div>
<a id="a2d7d79f3a3bbec799ef5876d858dacbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7d79f3a3bbec799ef5876d858dacbb">&#9670;&nbsp;</a></span>readRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MCP23008::readRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register number, typically one of the constants like <code>REG_IODIR</code> (0).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value. All <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register values are 8-bit (uint8_t).</dd></dl>
<p>There is no way to know if this actually succeeded. </p>

</div>
</div>
<a id="acbe7af5cf34651f28e6dbff2cede5040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbe7af5cf34651f28e6dbff2cede5040">&#9670;&nbsp;</a></span>readRegisterPin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MCP23008::readRegisterPin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register and masks off a specific bit. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register number, typically one of the constants like <code>REG_GPIO</code> (9).</td></tr>
    <tr><td class="paramname">pin</td><td>The pin 0 - 7</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the value boolean value</dd></dl>
<p>For registers that contain a bitmask of all 8 values (like REG_GPIO), reads all registers and then performs the necessary bit manipulation.</p>
<p>There is no way to know if this actually succeeded. </p>

</div>
</div>
<a id="a4dd3ba6a3fe5e694d88f12f3c29094e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dd3ba6a3fe5e694d88f12f3c29094e5">&#9670;&nbsp;</a></span>threadFunctionStatic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os_thread_return_t MCP23008::threadFunctionStatic </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Thread function, used internally. </p>
<p>There is only one thread for all instances of this object </p>

</div>
</div>
<a id="ab12092de931e6369a2914916dfac3537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab12092de931e6369a2914916dfac3537">&#9670;&nbsp;</a></span>withStackSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_c_p23008.html">MCP23008</a>&amp; MCP23008::withStackSize </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the stack size of the interrupt handler worker thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Size in bytes. Default is 1024.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns *this so you can chain options together, fluent-style.</dd></dl>
<p>You must call this before the first call to <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a>. Making the call after will have no effect. If multiple <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> objects are used (multiple chips) you must make this call before the first call to <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a> as all instances share a single thread. </p>

</div>
</div>
<a id="a52d8b5af1eafb4243cd13200993724fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d8b5af1eafb4243cd13200993724fe">&#9670;&nbsp;</a></span>writeRegister()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MCP23008::writeRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register number, typically one of the constants like <code>REG_IODIR</code> (0).</td></tr>
    <tr><td class="paramname">value</td><td>The value. All <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register values are 8-bit (uint8_t).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation completed successfully or false if not. </dd></dl>

</div>
</div>
<a id="a8f79acc17160392cdf52f73b24a5a4bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f79acc17160392cdf52f73b24a5a4bb">&#9670;&nbsp;</a></span>writeRegisterPin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool MCP23008::writeRegisterPin </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>pin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reads an <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> register, masks off a specific bit, and writes the register back. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reg</td><td>The register number, typically one of the constants like <code>REG_GPIO</code> (9).</td></tr>
    <tr><td class="paramname">pin</td><td>The pin 0 - 7</td></tr>
    <tr><td class="paramname">value</td><td>The bit value to set (true or false)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the I2C operation completed successfully or false if not.</dd></dl>
<p>For registers that contain a bitmask of all 8 values (like REG_GPIO), reads all registers, performs the necessary bit manipulation, and writes the register back.</p>
<p>The read/modify/write cycle is done within a single I2C lock()/unlock() pair to minimize the chance of simultaneous modification. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a4bfe2298280b73edd7f4a61ae0f23b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bfe2298280b73edd7f4a61ae0f23b06">&#9670;&nbsp;</a></span>addr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int MCP23008::addr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Which <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> to use (0-7) based on A0, A1, and A2 on the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a>. </p>
<p>This is just 0-7, the (0b0100000 of the 7-bit address is ORed in later) </p>

</div>
</div>
<a id="ac49807c0f884a0fcc990315759313b33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49807c0f884a0fcc990315759313b33">&#9670;&nbsp;</a></span>handlersMutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">os_mutex_t MCP23008::handlersMutex = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mutex used to prevent simultaneous use of interruptHandlers. </p>
<p>While technically you can use the vector from two threads at the same time, you can't modify it from another threads at the same time as it will break the iterator. Since we only read from one thread (the worker thread), this isn't a case worth optimizing for. </p>

</div>
</div>
<a id="a3638c276cc6697d949860de42d4bbb13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3638c276cc6697d949860de42d4bbb13">&#9670;&nbsp;</a></span>instances</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_m_c_p23008.html">MCP23008</a> * &gt; * MCP23008::instances</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Array of <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> object instances. </p>
<p>This is modified on the contructor and destructor for <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a>. It is used from the worker thread to handle all interrupts across all <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> objects from a single thread. </p>

</div>
</div>
<a id="a5d9bce4d7bfe4f1b388cfe46fab0a18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d9bce4d7bfe4f1b388cfe46fab0a18e">&#9670;&nbsp;</a></span>interruptHandlers</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_m_c_p23008_interrupt_handler.html">MCP23008InterruptHandler</a>*&gt; MCP23008::interruptHandlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of interrupt handlers. </p>
<p>This is used by <a class="el" href="class_m_c_p23008.html#ac750ccc8975257c48ddc11cea33e865b" title="Handles interrupts, used internally.">handleInterrupts()</a> and modified by <a class="el" href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb" title="Attaches an interrupt handler for a pin.">attachInterrupt()</a> and <a class="el" href="class_m_c_p23008.html#adf8b10a33c1aa31ca2464eb217de75ef" title="Detaches an interrupt handler for a pin.">detachInterrupt()</a>.</p>
<p>Simultaneous use is prevented by using handlersMutex and std::vector is not inherently thread-safe. </p>

</div>
</div>
<a id="a39eb7f35fa4bb97c75269f3ff3187741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39eb7f35fa4bb97c75269f3ff3187741">&#9670;&nbsp;</a></span>mcuInterruptPin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pin_t MCP23008::mcuInterruptPin = PIN_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The MCU GPIO the <a class="el" href="class_m_c_p23008.html" title="Class for the MCP23008 I2C GPIO chip.">MCP23008</a> INT pin is connected to. </p>
<p>Is <code>PIN_INVALID</code> if interrupts are not used. This is set by <code><a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a></code>. </p>

</div>
</div>
<a id="af128c623e67255371b9cf86309d007a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af128c623e67255371b9cf86309d007a6">&#9670;&nbsp;</a></span>stackSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t MCP23008::stackSize = 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default stack size for the worker thread. </p>
<p>You can change this using <a class="el" href="class_m_c_p23008.html#ab12092de931e6369a2914916dfac3537" title="Sets the stack size of the interrupt handler worker thread.">withStackSize()</a> before the first call to <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a> </p>

</div>
</div>
<a id="a9ce7445e2315b619d316999a0dc56baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce7445e2315b619d316999a0dc56baf">&#9670;&nbsp;</a></span>thread</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Thread * MCP23008::thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The worker thread object. </p>
<p>This is NULL before the first call to <a class="el" href="class_m_c_p23008.html#a42bb3eda6d39d42ce312de5b04efb1ed" title="Enables MCP23008 interrupt mode.">enableInterrupts()</a>. A single thread is shared by all instances of this object. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_m_c_p23008-_r_k_8h_source.html">MCP23008-RK.h</a></li>
<li>src/MCP23008-RK.cpp</li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclass_m_c_p23008_html_ae5a863cb4450c1249d45f77af8eebfdb"><div class="ttname"><a href="class_m_c_p23008.html#ae5a863cb4450c1249d45f77af8eebfdb">MCP23008::attachInterrupt</a></div><div class="ttdeci">void attachInterrupt(uint16_t pin, InterruptMode mode, std::function&lt; void(bool)&gt; handler)</div><div class="ttdoc">Attaches an interrupt handler for a pin.</div><div class="ttdef"><b>Definition:</b> MCP23008-RK.cpp:181</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
