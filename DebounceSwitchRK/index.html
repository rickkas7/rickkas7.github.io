<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DebounceSwitchRK: DebounceSwitchRK</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">DebounceSwitchRK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">DebounceSwitchRK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Library for switch debouncing for Particle devices</p>
<h1>Library features</h1>
<ul>
<li>Debounces both momentary (push button) and toggle switches.</li>
<li>For push buttons, handles long press, very long press, and multi-tap (double-tap, triple-tap, etc.).</li>
<li>Thread-based, so button changes are not lost even if loop() is blocked or delayed.</li>
<li>Handles buttons connected to 3V3 or GND (active high or active low) with internal or external pull.</li>
<li>Handles buttons connected to a GPIO pin.</li>
<li>Also handles buttons connected to expanders, such as MCP23008 I2C GPIO expanders.</li>
<li>Works with both polling (default) and notify-on-change (handy for I2C GPIO with interrupts).</li>
<li>Many configurable parameters.</li>
</ul>
<h1>General Design</h1>
<h2>Button Styles</h2>
<p>Different types of buttons (momentary push button or toggle), active high or low, with or without pull resistors, are specified using the <code>DebounceSwitchStyle</code> parameter to addSwitch().</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadLeft">Constant </th><th class="markdownTableHeadLeft">Purpose  </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">PRESS_LOW </td><td class="markdownTableBodyLeft">Momentary switch to GND with an external pull-up  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">PRESS_HIGH </td><td class="markdownTableBodyLeft">Momentary switch to 3V3 with an external pull-down  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">PRESS_LOW_PULLUP </td><td class="markdownTableBodyLeft">Momentary switch to GND, along with using the MCU internal pull-up resistor  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">PRESS_HIGH_PULLDOWN </td><td class="markdownTableBodyLeft">Momentary switch to 3V3, along with using the MCU internal pull-up resistor  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TOGGLE </td><td class="markdownTableBodyLeft">Toggle (on/off) switch that drives the input to GND or 3V3  </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyLeft">TOGGLE_PULLDOWN </td><td class="markdownTableBodyLeft">Toggle switch that connects the input to 3V3 in one position and disconnected in the other  </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyLeft">TOGGLE_PULLUP </td><td class="markdownTableBodyLeft">Toggle switch that connects the input to GND in one position and disconnected in the other  </td></tr>
</table>
<p>If you are designing a new circuit, the best option is to have your switch connect the GPIO to GND (not 3V3) and use on the of the MCU pull-up modes. So <code>PRESS_LOW_PULLUP</code> for a momentary push-button switch or <code>TOGGLE_PULLUP</code> for a toggle switch.</p>
<h2>Callbacks</h2>
<p>This library uses a thread and a callback approach. Even if the GPIO are polled (as is typically the case for hardware GPIO connected to the MCU), you will be notified of debounced press and tap events using a callback.</p>
<p>The callback has this prototype:</p>
<div class="fragment"><div class="line">void callback(DebounceSwitchState *switchState, void *context);</div>
</div><!-- fragment --><ul>
<li>switchState is an object pointer for the switch that caused the event, and also what happened.</li>
<li>context is an optional pointer you passed into addSwitch() you can use to communicate extra data to the callback.</li>
</ul>
<p>It's also possible to make the callback a class member function of a class you've created.</p>
<div class="fragment"><div class="line">void YourClass::callback(DebounceSwitchState *switchState);</div>
</div><!-- fragment --><p>The callback is called from a worker thread with a small (1024 byte) stack, so you should avoid doing operations which block or use a lot of stack space.</p>
<p>Returning as quickly as possible without blocking is the best. If you must block, make sure you don't block more than 5 milliseconds total or the debouncing of the buttons and performance will be affected.</p>
<h2>Polling Callback</h2>
<p>If you are using GPIO connected to another chip, you can provide a pollCallback to poll the GPIO values. For example, if you have an MCP23008 I2C GPIO expander, you can connect buttons to that.</p>
<p>The poolCallback has this prototype:</p>
<div class="fragment"><div class="line">bool callback(DebounceSwitchState *switchState, void *context);</div>
</div><!-- fragment --><ul>
<li>switchState is an object pointer for the switch that caused the event, and also what happened.</li>
<li>context is an optional pointer you passed into addSwitch() you can use to communicate extra data to the callback.</li>
</ul>
<p>Note that the pollCallback returns a bool for the state of the GPIO (false = LOW, true = HIGH).</p>
<p>It's also possible to make the pollCallback a class member function of a class you've created.</p>
<div class="fragment"><div class="line">bool YourClass::callback(DebounceSwitchState *switchState);</div>
</div><!-- fragment --><p>If you are using an external GPIO you need to manage the pull resistors in your own code, so you'd use one of switch types <code>PRESS_LOW</code>, <code>PRESS_HIGH</code>, or <code>TOGGLE</code>.</p>
<h2>Notify Mode</h2>
<p>In some cases, it's inefficient to poll the switch. Polling happens every 5 milliseconds by default, which is fine for GPIO connected directly to the MCU. However, if the GPIO is on an I2C expander, it's still well within the capabilities of I2C, but it can be made more efficient.</p>
<p>The MCP23008 supports interrupt mode. When the external GPIO changes state, it sets an output that is read by a hardware GPIO on the MCU. This allows the MCU to determine if a change has occurred on the expander without having to do an I2C transaction; instead if can just read a hardware GPIO.</p>
<p>The MCP23008-RK library supports this mode, and allows for a callback to be called when the external GPIO state changes. This callback can then use the notify mode of the DebounceSwitchRK library to tell the debouncer what the current state of the switch signal is.</p>
<p>See the example in more-tests/02-mcp23008-interrupts:</p>
<div class="fragment"><div class="line">DebounceSwitchState *sw = DebounceSwitch::getInstance()-&gt;addNotifySwitch(DebounceSwitchStyle::PRESS_LOW, </div>
<div class="line">    [](DebounceSwitchState *switchState, void *) {</div>
<div class="line">        // Called to notify of switch operations</div>
<div class="line">        Log.info(&quot;state=%s&quot;, switchState-&gt;getPressStateName());</div>
<div class="line">        if (switchState-&gt;getPressState() == DebouncePressState::TAP) {</div>
<div class="line">            Log.info(&quot;%d taps&quot;, switchState-&gt;getTapCount());</div>
<div class="line">        }</div>
<div class="line">    }, NULL);</div>
<div class="line"> </div>
<div class="line">gpio.attachInterrupt(SWITCH_PIN, CHANGE, [sw](bool bValue) {</div>
<div class="line">    // Log.info(&quot;bValue=%d&quot;, bValue);</div>
<div class="line">    sw-&gt;notify(bValue);</div>
<div class="line">});</div>
</div><!-- fragment --><h1><a class="el" href="class_debounce_configuration.html" title="Container for timing-related settings for switches.">DebounceConfiguration</a></h1>
<p>There are a number of configurable parameters. They can be set globally, for future calls to addSwitch(), per-switch, if desired.</p>
<p>For example:</p>
<div class="fragment"><div class="line">void setup() {</div>
<div class="line">    DebounceSwitch::getInstance()-&gt;setup();</div>
<div class="line"> </div>
<div class="line">    // Disable very long press mode</div>
<div class="line">    DebounceSwitch::getInstance()-&gt;withNoVeryLongPress();</div>
<div class="line"> </div>
<div class="line">    DebounceSwitch::getInstance()-&gt;addSwitch(TEST_PIN, DebounceSwitchStyle::PRESS_LOW_PULLUP, </div>
<div class="line">        [](DebounceSwitchState *switchState, void *) {</div>
<div class="line">            Log.info(&quot;pin=%d state=%s&quot;, switchState-&gt;getPin(), switchState-&gt;getPressStateName());</div>
<div class="line">            if (switchState-&gt;getPressState() == DebouncePressState::TAP) {</div>
<div class="line">                Log.info(&quot;%d taps&quot;, switchState-&gt;getTapCount());</div>
<div class="line">            }</div>
<div class="line">    });</div>
<div class="line">}</div>
</div><!-- fragment --><p>This changes the default, then adds a switch. If you change the default again, the existing switch will not be changed, but future calls to addSwitch() will be affected.</p>
<h2>Per switch configuration</h2>
<div class="fragment"><div class="line">#include &quot;DebounceSwitchRK.h&quot;</div>
<div class="line"> </div>
<div class="line">SYSTEM_THREAD(ENABLED);</div>
<div class="line"> </div>
<div class="line">SerialLogHandler logHandler;</div>
<div class="line"> </div>
<div class="line">void switchCallback(DebounceSwitchState *switchState, void *) {</div>
<div class="line">    const char *name = (switchState-&gt;getPin() == D2) ? &quot;toggle D2&quot; : &quot;button D3&quot;;</div>
<div class="line">    Log.info(&quot;%s state=%s&quot;, name, switchState-&gt;getPressStateName());</div>
<div class="line"> </div>
<div class="line">    if (switchState-&gt;getPressState() == DebouncePressState::TAP) {</div>
<div class="line">        Log.info(&quot;%d taps&quot;, switchState-&gt;getTapCount());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line">    DebounceSwitch::getInstance()-&gt;setup();</div>
<div class="line"> </div>
<div class="line">    DebounceSwitchState *sw;</div>
<div class="line">    </div>
<div class="line">    // Toggle switch</div>
<div class="line">    sw = DebounceSwitch::getInstance()-&gt;addSwitch(D2, DebounceSwitchStyle::TOGGLE_PULLUP, switchCallback);</div>
<div class="line">    // Give the toggle switch a longer debounce time</div>
<div class="line">    sw-&gt;withDebounceMs(100);</div>
<div class="line"> </div>
<div class="line">    // Push button switch</div>
<div class="line">    sw = DebounceSwitch::getInstance()-&gt;addSwitch(D3, DebounceSwitchStyle::PRESS_LOW_PULLUP, switchCallback);</div>
<div class="line">    // Disable long press and very long press mode on the button</div>
<div class="line">    sw-&gt;withNoLongPress();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">}</div>
</div><!-- fragment --><p>The same methods also work for on the <a class="el" href="class_debounce_switch_state.html" title="Configuration and state for a single switch.">DebounceSwitchState</a> object, so you can set the parameters per-switch.</p>
<h1>Usage Patterns</h1>
<h2>Hardware GPIO, Simple Callback</h2>
<div class="fragment"><div class="line">#include &quot;Particle.h&quot;</div>
<div class="line"> </div>
<div class="line">#include &quot;DebounceSwitchRK.h&quot;</div>
<div class="line"> </div>
<div class="line">SYSTEM_THREAD(ENABLED);</div>
<div class="line"> </div>
<div class="line">SerialLogHandler logHandler;</div>
<div class="line"> </div>
<div class="line">void switchCallback(DebounceSwitchState *switchState, void *context) {</div>
<div class="line">    // This function is called from a worker thread with a small (1K) stack.</div>
<div class="line">    // You should avoid any large, lengthy operations here.</div>
<div class="line">    Log.info(&quot;pin=%d state=%s&quot;, switchState-&gt;getPin(), switchState-&gt;getPressStateName());</div>
<div class="line">    if (switchState-&gt;getPressState() == DebouncePressState::TAP) {</div>
<div class="line">        Log.info(&quot;%d taps&quot;, switchState-&gt;getTapCount());</div>
<div class="line">    }    </div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void setup() {</div>
<div class="line">    DebounceSwitch::getInstance()-&gt;setup();</div>
<div class="line"> </div>
<div class="line">    DebounceSwitch::getInstance()-&gt;addSwitch(D3, DebounceSwitchStyle::PRESS_LOW_PULLUP, switchCallback);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">void loop() {</div>
<div class="line">}</div>
</div><!-- fragment --><p>This is the simplest model for GPIO connected switches. Of note:</p>
<div class="fragment"><div class="line">DebounceSwitch::getInstance()-&gt;setup();</div>
</div><!-- fragment --><p>Be sure to call this from global setup(). It's required!</p>
<div class="fragment"><div class="line">DebounceSwitch::getInstance()-&gt;addSwitch(D3, DebounceSwitchStyle::PRESS_LOW_PULLUP, switchCallback);</div>
</div><!-- fragment --><p>This is how you add a switch to be handled. You can add multiple switches in this manner.</p>
<p>The parameters of interest are:</p>
<ul>
<li><code>D3</code> The pin the switch is connected to</li>
<li><code>DebounceSwitchStyle::PRESS_LOW_PULLUP</code> The switch is a momentary (push-button) switch and connects the GPIO to GND (active low). It uses the MCU's hardware pull-up to handle the case where the switch is open (not connected) to bring the signal HIGH.</li>
<li><code>switchCallback</code> The function below.</li>
</ul>
<p>This is the callback function:</p>
<div class="fragment"><div class="line">void switchCallback(DebounceSwitchState *switchState, void *context) {</div>
<div class="line">    Log.info(&quot;pin=%d state=%s&quot;, switchState-&gt;getPin(), switchState-&gt;getPressStateName());</div>
<div class="line">    if (switchState-&gt;getPressState() == DebouncePressState::TAP) {</div>
<div class="line">        Log.info(&quot;%d taps&quot;, switchState-&gt;getTapCount());</div>
<div class="line">    }    </div>
<div class="line">}</div>
</div><!-- fragment --><p>The callback is called from a worker thread with a small (1024 byte) stack, so you should avoid doing operations which block or use a lot of stack space. This example just logs things to debug USB serial using <code>Log.info</code>.</p>
<p>Note that there is no code needed from loop(). This means that if your code is blocking loop, it won't adversely affect the handling of buttons.</p>
<h2>Hardware GPIO, Lambda Callback</h2>
<p>The callback can be a C++11 lambda function:</p>
<div class="fragment"><div class="line">DebounceSwitch::getInstance()-&gt;addSwitch(D2, DebounceSwitchStyle::TOGGLE, [](DebounceSwitchState *switchState, void *) {</div>
<div class="line">    Log.info(&quot;toggle state=%s&quot;, switchState-&gt;getPressStateName());</div>
<div class="line">});</div>
</div><!-- fragment --><p>This is the actual lambda part:</p>
<div class="fragment"><div class="line">[](DebounceSwitchState *switchState, void *) {</div>
<div class="line">    Log.info(&quot;toggle state=%s&quot;, switchState-&gt;getPressStateName());</div>
<div class="line">}</div>
</div><!-- fragment --><p>This declared a function in-line to be called when the event occurs. The function has this prototype:</p>
<div class="fragment"><div class="line">void callback(DebounceSwitchState *switchState, void *)</div>
</div><!-- fragment --><p>It's important to remember the callback part is execute later, not inline with the rest of the code.</p>
<p>The <code>[]</code> part is the lambda capture, which allows local variables and <code>this</code> (for C++ class instances) to be captured for use within the lambda function. In this case, there is nothing to capture. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
