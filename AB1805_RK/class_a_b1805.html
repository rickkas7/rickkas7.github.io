<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AB1805_RK: AB1805 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">AB1805_RK
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">AB1805 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for using the AB1805/AM1805 RTC/watchdog chip.  
 <a href="class_a_b1805.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_a_b1805___r_k_8h_source.html">AB1805_RK.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:afad2003d2b92d21f56faf48dbec790c5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5">WakeReason</a> { <br />
&#160;&#160;<a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5a696b031073e74bf2cb98e5ef201d4aa3">WakeReason::UNKNOWN</a>, 
<a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5ae8e0182f554bb505df81621069717de7">WakeReason::WATCHDOG</a>, 
<a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5a7490d3d9f861bacc8815171784f79d7b">WakeReason::DEEP_POWER_DOWN</a>, 
<a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5ae41eb276fb434d351ce14a486dedf66b">WakeReason::COUNTDOWN_TIMER</a>, 
<br />
&#160;&#160;<a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5a9de6d0a670ae5a0dee31a6318aa00e8d">WakeReason::ALARM</a>
<br />
 }</td></tr>
<tr class="memdesc:afad2003d2b92d21f56faf48dbec790c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return codes for <a class="el" href="class_a_b1805.html#a8da821fd718c0c72af2d2849ffe23559" title="Gets the reason the device was reset or woken. For example, TIMER, ALARM, WATCHDOG,...">getWakeReason()</a>  <a href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5">More...</a><br /></td></tr>
<tr class="separator:afad2003d2b92d21f56faf48dbec790c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5e32299bbe31841fcbeb73d2175ccb65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5e32299bbe31841fcbeb73d2175ccb65">AB1805</a> (TwoWire &amp;<a class="el" href="class_a_b1805.html#a1144ea899a90e5b3f4f54ee819832656">wire</a>=Wire, uint8_t <a class="el" href="class_a_b1805.html#a98648dc7b965fed0a114061301ff92c3">i2cAddr</a>=0x69)</td></tr>
<tr class="memdesc:a5e32299bbe31841fcbeb73d2175ccb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> driver object.  <a href="class_a_b1805.html#a5e32299bbe31841fcbeb73d2175ccb65">More...</a><br /></td></tr>
<tr class="separator:a5e32299bbe31841fcbeb73d2175ccb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f04896fbd8befc1ff9a88ab6d0b1c22"><td class="memItemLeft" align="right" valign="top"><a id="a2f04896fbd8befc1ff9a88ab6d0b1c22"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2f04896fbd8befc1ff9a88ab6d0b1c22">~AB1805</a> ()</td></tr>
<tr class="memdesc:a2f04896fbd8befc1ff9a88ab6d0b1c22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. Not normally used as this object is typically a global object. <br /></td></tr>
<tr class="separator:a2f04896fbd8befc1ff9a88ab6d0b1c22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b597349a25f03f380a3261a5b9f0045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045">setup</a> (bool callBegin=true)</td></tr>
<tr class="memdesc:a6b597349a25f03f380a3261a5b9f0045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this from main <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">setup()</a> to initialize the library.  <a href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045">More...</a><br /></td></tr>
<tr class="separator:a6b597349a25f03f380a3261a5b9f0045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8640af3fba5486740b2fc5acf7b1672"><td class="memItemLeft" align="right" valign="top"><a id="aa8640af3fba5486740b2fc5acf7b1672"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672">loop</a> ()</td></tr>
<tr class="memdesc:aa8640af3fba5486740b2fc5acf7b1672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this from main <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">loop()</a>. Should be called on every call to <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">loop()</a>. <br /></td></tr>
<tr class="separator:aa8640af3fba5486740b2fc5acf7b1672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b9c585aea461af5e0ff80da49f4acc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_b1805.html">AB1805</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a05b9c585aea461af5e0ff80da49f4acc">withFOUT</a> (pin_t pin)</td></tr>
<tr class="memdesc:a05b9c585aea461af5e0ff80da49f4acc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call this before <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">AB1805::setup()</a> to specify the pin connected to FOUT/nIRQ.  <a href="class_a_b1805.html#a05b9c585aea461af5e0ff80da49f4acc">More...</a><br /></td></tr>
<tr class="separator:a05b9c585aea461af5e0ff80da49f4acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0527f95937cc13acfce4e84b708d32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aab0527f95937cc13acfce4e84b708d32">detectChip</a> ()</td></tr>
<tr class="memdesc:aab0527f95937cc13acfce4e84b708d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the I2C bus to make sure there is an <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> present.  <a href="class_a_b1805.html#aab0527f95937cc13acfce4e84b708d32">More...</a><br /></td></tr>
<tr class="separator:aab0527f95937cc13acfce4e84b708d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8b06308fed7a847d07ec29e2a3e6c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2d8b06308fed7a847d07ec29e2a3e6c4">usingRCOscillator</a> ()</td></tr>
<tr class="memdesc:a2d8b06308fed7a847d07ec29e2a3e6c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check oscillator.  <a href="class_a_b1805.html#a2d8b06308fed7a847d07ec29e2a3e6c4">More...</a><br /></td></tr>
<tr class="separator:a2d8b06308fed7a847d07ec29e2a3e6c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df1720dee0e46d3db1a7278f445203f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a1df1720dee0e46d3db1a7278f445203f">isRTCSet</a> ()</td></tr>
<tr class="memdesc:a1df1720dee0e46d3db1a7278f445203f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the RTC has been set.  <a href="class_a_b1805.html#a1df1720dee0e46d3db1a7278f445203f">More...</a><br /></td></tr>
<tr class="separator:a1df1720dee0e46d3db1a7278f445203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da821fd718c0c72af2d2849ffe23559"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5">WakeReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8da821fd718c0c72af2d2849ffe23559">getWakeReason</a> () const</td></tr>
<tr class="memdesc:a8da821fd718c0c72af2d2849ffe23559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the reason the device was reset or woken. For example, TIMER, ALARM, WATCHDOG, etc.  <a href="class_a_b1805.html#a8da821fd718c0c72af2d2849ffe23559">More...</a><br /></td></tr>
<tr class="separator:a8da821fd718c0c72af2d2849ffe23559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd13ad2d31fb669977142b39dca9e37e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afd13ad2d31fb669977142b39dca9e37e">updateWakeReason</a> ()</td></tr>
<tr class="memdesc:afd13ad2d31fb669977142b39dca9e37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the wake reason. This is needed after STOP mode System.sleep()  <a href="class_a_b1805.html#afd13ad2d31fb669977142b39dca9e37e">More...</a><br /></td></tr>
<tr class="separator:afd13ad2d31fb669977142b39dca9e37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889f51cd5a025428c683b2842d9d52ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a889f51cd5a025428c683b2842d9d52ff">setWDT</a> (int seconds=-1)</td></tr>
<tr class="memdesc:a889f51cd5a025428c683b2842d9d52ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set or reset the watchdog timer.  <a href="class_a_b1805.html#a889f51cd5a025428c683b2842d9d52ff">More...</a><br /></td></tr>
<tr class="separator:a889f51cd5a025428c683b2842d9d52ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c75e4e820a2715c734eec1aa1864c28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7c75e4e820a2715c734eec1aa1864c28">stopWDT</a> ()</td></tr>
<tr class="memdesc:a7c75e4e820a2715c734eec1aa1864c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops the watchdog timer. Useful before entering sleep mode.  <a href="class_a_b1805.html#a7c75e4e820a2715c734eec1aa1864c28">More...</a><br /></td></tr>
<tr class="separator:a7c75e4e820a2715c734eec1aa1864c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f9d71f35eaac964ee22e06d7ec505e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a78f9d71f35eaac964ee22e06d7ec505e">resumeWDT</a> ()</td></tr>
<tr class="memdesc:a78f9d71f35eaac964ee22e06d7ec505e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes watchdog with same settings as before.  <a href="class_a_b1805.html#a78f9d71f35eaac964ee22e06d7ec505e">More...</a><br /></td></tr>
<tr class="separator:a78f9d71f35eaac964ee22e06d7ec505e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2ccbed689ea8aa0197705dfa9696ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afc2ccbed689ea8aa0197705dfa9696ec">getRtcAsTime</a> (time_t &amp;time)</td></tr>
<tr class="memdesc:afc2ccbed689ea8aa0197705dfa9696ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time from the RTC as a time_t.  <a href="class_a_b1805.html#afc2ccbed689ea8aa0197705dfa9696ec">More...</a><br /></td></tr>
<tr class="separator:afc2ccbed689ea8aa0197705dfa9696ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a69833d9a015dce8e7f5bbb55a99fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a92a69833d9a015dce8e7f5bbb55a99fc">getRtcAsTm</a> (struct tm *timeptr)</td></tr>
<tr class="memdesc:a92a69833d9a015dce8e7f5bbb55a99fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the time from the RTC as a struct tm.  <a href="class_a_b1805.html#a92a69833d9a015dce8e7f5bbb55a99fc">More...</a><br /></td></tr>
<tr class="separator:a92a69833d9a015dce8e7f5bbb55a99fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee9d908319670a76d876763886ffd939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aee9d908319670a76d876763886ffd939">resetConfig</a> (uint32_t flags=0)</td></tr>
<tr class="memdesc:aee9d908319670a76d876763886ffd939"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the configuration of the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> to default settings.  <a href="class_a_b1805.html#aee9d908319670a76d876763886ffd939">More...</a><br /></td></tr>
<tr class="separator:aee9d908319670a76d876763886ffd939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d085590f8fc332808d3c8aa58c8e17c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5d085590f8fc332808d3c8aa58c8e17c">interruptAtTime</a> (time_t time)</td></tr>
<tr class="memdesc:a5d085590f8fc332808d3c8aa58c8e17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an interrupt at a time in the future using a time_t.  <a href="class_a_b1805.html#a5d085590f8fc332808d3c8aa58c8e17c">More...</a><br /></td></tr>
<tr class="separator:a5d085590f8fc332808d3c8aa58c8e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf74b3ae927cccbba8025af60b111ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7cf74b3ae927cccbba8025af60b111ac">interruptAtTm</a> (struct tm *timeptr)</td></tr>
<tr class="memdesc:a7cf74b3ae927cccbba8025af60b111ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an interrupt at a time in the future using a struct tm *.  <a href="class_a_b1805.html#a7cf74b3ae927cccbba8025af60b111ac">More...</a><br /></td></tr>
<tr class="separator:a7cf74b3ae927cccbba8025af60b111ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95deb0ee00170824c8a1df71207a3d90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a95deb0ee00170824c8a1df71207a3d90">repeatingInterrupt</a> (struct tm *timeptr, uint8_t rptValue)</td></tr>
<tr class="memdesc:a95deb0ee00170824c8a1df71207a3d90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a repeating interrupt.  <a href="class_a_b1805.html#a95deb0ee00170824c8a1df71207a3d90">More...</a><br /></td></tr>
<tr class="separator:a95deb0ee00170824c8a1df71207a3d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ea444cda68d3ffbda6de2d8bb44a8d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5ea444cda68d3ffbda6de2d8bb44a8d1">clearRepeatingInterrupt</a> ()</td></tr>
<tr class="memdesc:a5ea444cda68d3ffbda6de2d8bb44a8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear repeating interrupt set with <code><a class="el" href="class_a_b1805.html#a95deb0ee00170824c8a1df71207a3d90" title="Set a repeating interrupt.">repeatingInterrupt()</a></code>.  <a href="class_a_b1805.html#a5ea444cda68d3ffbda6de2d8bb44a8d1">More...</a><br /></td></tr>
<tr class="separator:a5ea444cda68d3ffbda6de2d8bb44a8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6cb815e28b2146cb88e999b78da16e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8c6cb815e28b2146cb88e999b78da16e">interruptCountdownTimer</a> (int value, bool minutes)</td></tr>
<tr class="memdesc:a8c6cb815e28b2146cb88e999b78da16e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt at a time in the future, either in minutes or seconds.  <a href="class_a_b1805.html#a8c6cb815e28b2146cb88e999b78da16e">More...</a><br /></td></tr>
<tr class="separator:a8c6cb815e28b2146cb88e999b78da16e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477a5b2fc850d1a6d3e019af4e960da0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a477a5b2fc850d1a6d3e019af4e960da0">deepPowerDown</a> (int seconds=30)</td></tr>
<tr class="memdesc:a477a5b2fc850d1a6d3e019af4e960da0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters deep power down reset mode, using the EN pin.  <a href="class_a_b1805.html#a477a5b2fc850d1a6d3e019af4e960da0">More...</a><br /></td></tr>
<tr class="separator:a477a5b2fc850d1a6d3e019af4e960da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3de973020fef6592646b0c948923bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6f3de973020fef6592646b0c948923bc">setCountdownTimer</a> (int value, bool minutes)</td></tr>
<tr class="memdesc:a6f3de973020fef6592646b0c948923bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used internally by interruptCountdownTimer and deepPowerDown.  <a href="class_a_b1805.html#a6f3de973020fef6592646b0c948923bc">More...</a><br /></td></tr>
<tr class="separator:a6f3de973020fef6592646b0c948923bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa233adaafd65b19876568699dccd762"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afa233adaafd65b19876568699dccd762">setTrickle</a> (uint8_t diodeAndRout)</td></tr>
<tr class="memdesc:afa233adaafd65b19876568699dccd762"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable trickle charging mode.  <a href="class_a_b1805.html#afa233adaafd65b19876568699dccd762">More...</a><br /></td></tr>
<tr class="separator:afa233adaafd65b19876568699dccd762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4fb028700fb69023a87f9cc72abab11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab4fb028700fb69023a87f9cc72abab11">isVBATAboveMin</a> ()</td></tr>
<tr class="memdesc:ab4fb028700fb69023a87f9cc72abab11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if VBAT input is above minimum operating voltage (1.2V)  <a href="class_a_b1805.html#ab4fb028700fb69023a87f9cc72abab11">More...</a><br /></td></tr>
<tr class="separator:ab4fb028700fb69023a87f9cc72abab11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9ae3d3f3a045119004dad192a373fd9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac9ae3d3f3a045119004dad192a373fd9">isVBATAboveBREF</a> ()</td></tr>
<tr class="memdesc:ac9ae3d3f3a045119004dad192a373fd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if VBAT input is above BREF voltage.  <a href="class_a_b1805.html#ac9ae3d3f3a045119004dad192a373fd9">More...</a><br /></td></tr>
<tr class="separator:ac9ae3d3f3a045119004dad192a373fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69e97a9fd017318a5b88b55f7193f0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#af69e97a9fd017318a5b88b55f7193f0d">checkVBAT</a> (uint8_t mask, bool &amp;isAbove)</td></tr>
<tr class="memdesc:af69e97a9fd017318a5b88b55f7193f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks VBAT status.  <a href="class_a_b1805.html#af69e97a9fd017318a5b88b55f7193f0d">More...</a><br /></td></tr>
<tr class="separator:af69e97a9fd017318a5b88b55f7193f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2655a5e1928d658b443a45c7f10a026f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2655a5e1928d658b443a45c7f10a026f">setRtcFromSystem</a> ()</td></tr>
<tr class="memdesc:a2655a5e1928d658b443a45c7f10a026f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the RTC from the system clock.  <a href="class_a_b1805.html#a2655a5e1928d658b443a45c7f10a026f">More...</a><br /></td></tr>
<tr class="separator:a2655a5e1928d658b443a45c7f10a026f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6f9310f9d60c9c1e834cbcff5ae8c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3d6f9310f9d60c9c1e834cbcff5ae8c4">setRtcFromTime</a> (time_t time, bool lock=true)</td></tr>
<tr class="memdesc:a3d6f9310f9d60c9c1e834cbcff5ae8c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RTC from a time_t.  <a href="class_a_b1805.html#a3d6f9310f9d60c9c1e834cbcff5ae8c4">More...</a><br /></td></tr>
<tr class="separator:a3d6f9310f9d60c9c1e834cbcff5ae8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681f919fa1d706383d1b8a4ba68703fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a681f919fa1d706383d1b8a4ba68703fc">setRtcFromTm</a> (const struct tm *timeptr, bool lock=true)</td></tr>
<tr class="memdesc:a681f919fa1d706383d1b8a4ba68703fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the RTC from a time_t.  <a href="class_a_b1805.html#a681f919fa1d706383d1b8a4ba68703fc">More...</a><br /></td></tr>
<tr class="separator:a681f919fa1d706383d1b8a4ba68703fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af14273577e543d6998d721a47edb4d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#af14273577e543d6998d721a47edb4d15">readRegister</a> (uint8_t regAddr, uint8_t &amp;value, bool lock=true)</td></tr>
<tr class="memdesc:af14273577e543d6998d721a47edb4d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte)  <a href="class_a_b1805.html#af14273577e543d6998d721a47edb4d15">More...</a><br /></td></tr>
<tr class="separator:af14273577e543d6998d721a47edb4d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6170ce3c6c9427df4972d2a5947b51"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7d6170ce3c6c9427df4972d2a5947b51">readRegister</a> (uint8_t regAddr, bool lock=true)</td></tr>
<tr class="memdesc:a7d6170ce3c6c9427df4972d2a5947b51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte) and returns it.  <a href="class_a_b1805.html#a7d6170ce3c6c9427df4972d2a5947b51">More...</a><br /></td></tr>
<tr class="separator:a7d6170ce3c6c9427df4972d2a5947b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474382cce9b4727690059d0f46a0f1ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a474382cce9b4727690059d0f46a0f1ca">readRegisters</a> (uint8_t regAddr, uint8_t *array, size_t num, bool lock=true)</td></tr>
<tr class="memdesc:a474382cce9b4727690059d0f46a0f1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads sequential registers.  <a href="class_a_b1805.html#a474382cce9b4727690059d0f46a0f1ca">More...</a><br /></td></tr>
<tr class="separator:a474382cce9b4727690059d0f46a0f1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154f52145b4e0344d283aa203feab2b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a154f52145b4e0344d283aa203feab2b4">writeRegister</a> (uint8_t regAddr, uint8_t value, bool lock=true)</td></tr>
<tr class="memdesc:a154f52145b4e0344d283aa203feab2b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte)  <a href="class_a_b1805.html#a154f52145b4e0344d283aa203feab2b4">More...</a><br /></td></tr>
<tr class="separator:a154f52145b4e0344d283aa203feab2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d38509c2fcf4f2a397607d6ee7014"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac83d38509c2fcf4f2a397607d6ee7014">writeRegisters</a> (uint8_t regAddr, const uint8_t *array, size_t num, bool lock=true)</td></tr>
<tr class="memdesc:ac83d38509c2fcf4f2a397607d6ee7014"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes sequential <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> registers.  <a href="class_a_b1805.html#ac83d38509c2fcf4f2a397607d6ee7014">More...</a><br /></td></tr>
<tr class="separator:ac83d38509c2fcf4f2a397607d6ee7014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab240035c2ff0fa3762a04626e3b463e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab240035c2ff0fa3762a04626e3b463e3">maskRegister</a> (uint8_t regAddr, uint8_t andValue, uint8_t orValue, bool lock=true)</td></tr>
<tr class="memdesc:ab240035c2ff0fa3762a04626e3b463e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte) with masking of existing value.  <a href="class_a_b1805.html#ab240035c2ff0fa3762a04626e3b463e3">More...</a><br /></td></tr>
<tr class="separator:ab240035c2ff0fa3762a04626e3b463e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c8d879652bb66cfd0b8235682c9a1e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5c8d879652bb66cfd0b8235682c9a1e9">isBitClear</a> (uint8_t regAddr, uint8_t bitMask, bool lock=true)</td></tr>
<tr class="memdesc:a5c8d879652bb66cfd0b8235682c9a1e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a bit in a register is 0.  <a href="class_a_b1805.html#a5c8d879652bb66cfd0b8235682c9a1e9">More...</a><br /></td></tr>
<tr class="separator:a5c8d879652bb66cfd0b8235682c9a1e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42f7fb5588a7c136a79dcdf987d8621"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac42f7fb5588a7c136a79dcdf987d8621">isBitSet</a> (uint8_t regAddr, uint8_t bitMask, bool lock=true)</td></tr>
<tr class="memdesc:ac42f7fb5588a7c136a79dcdf987d8621"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a bit in a register is 1.  <a href="class_a_b1805.html#ac42f7fb5588a7c136a79dcdf987d8621">More...</a><br /></td></tr>
<tr class="separator:ac42f7fb5588a7c136a79dcdf987d8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a119407078df15ab7036dab66402c0ee3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a119407078df15ab7036dab66402c0ee3">clearRegisterBit</a> (uint8_t regAddr, uint8_t bitMask, bool lock=true)</td></tr>
<tr class="memdesc:a119407078df15ab7036dab66402c0ee3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear a bit in a register.  <a href="class_a_b1805.html#a119407078df15ab7036dab66402c0ee3">More...</a><br /></td></tr>
<tr class="separator:a119407078df15ab7036dab66402c0ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d21a24845cb60124691b14b17da84c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3d21a24845cb60124691b14b17da84c4">setRegisterBit</a> (uint8_t regAddr, uint8_t bitMask, bool lock=true)</td></tr>
<tr class="memdesc:a3d21a24845cb60124691b14b17da84c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a bit in a register.  <a href="class_a_b1805.html#a3d21a24845cb60124691b14b17da84c4">More...</a><br /></td></tr>
<tr class="separator:a3d21a24845cb60124691b14b17da84c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8be547f0bdbcf70a44435513f43785"><td class="memItemLeft" align="right" valign="top"><a id="aec8be547f0bdbcf70a44435513f43785"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aec8be547f0bdbcf70a44435513f43785">length</a> ()</td></tr>
<tr class="memdesc:aec8be547f0bdbcf70a44435513f43785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the length of the RTC RAM in bytes (always 256) <br /></td></tr>
<tr class="separator:aec8be547f0bdbcf70a44435513f43785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791920f84716d1bb3eaa529857eb8bab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a791920f84716d1bb3eaa529857eb8bab">eraseRam</a> (bool lock=true)</td></tr>
<tr class="memdesc:a791920f84716d1bb3eaa529857eb8bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erases the RTC RAM to 0x00 values.  <a href="class_a_b1805.html#a791920f84716d1bb3eaa529857eb8bab">More...</a><br /></td></tr>
<tr class="separator:a791920f84716d1bb3eaa529857eb8bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43558bc27b5020ece8d69597d61fd81b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a43558bc27b5020ece8d69597d61fd81b"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a43558bc27b5020ece8d69597d61fd81b">get</a> (size_t ramAddr, T &amp;t)</td></tr>
<tr class="memdesc:a43558bc27b5020ece8d69597d61fd81b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read from RTC RAM using EEPROM-style API.  <a href="class_a_b1805.html#a43558bc27b5020ece8d69597d61fd81b">More...</a><br /></td></tr>
<tr class="separator:a43558bc27b5020ece8d69597d61fd81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7abf2aef84d17b61641c37893d4275f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7abf2aef84d17b61641c37893d4275f5"><td class="memTemplItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7abf2aef84d17b61641c37893d4275f5">put</a> (size_t ramAddr, const T &amp;t)</td></tr>
<tr class="memdesc:a7abf2aef84d17b61641c37893d4275f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write from RTC RAM using EEPROM-style API.  <a href="class_a_b1805.html#a7abf2aef84d17b61641c37893d4275f5">More...</a><br /></td></tr>
<tr class="separator:a7abf2aef84d17b61641c37893d4275f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabf727cf88995b19371b15dbe4dd3ac0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aabf727cf88995b19371b15dbe4dd3ac0">readRam</a> (size_t ramAddr, uint8_t *data, size_t dataLen, bool lock=true)</td></tr>
<tr class="memdesc:aabf727cf88995b19371b15dbe4dd3ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level read call.  <a href="class_a_b1805.html#aabf727cf88995b19371b15dbe4dd3ac0">More...</a><br /></td></tr>
<tr class="separator:aabf727cf88995b19371b15dbe4dd3ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86b7c3c3649185301c4a42a2a3465cd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac86b7c3c3649185301c4a42a2a3465cd">writeRam</a> (size_t ramAddr, const uint8_t *data, size_t dataLen, bool lock=true)</td></tr>
<tr class="memdesc:ac86b7c3c3649185301c4a42a2a3465cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low-level write call.  <a href="class_a_b1805.html#ac86b7c3c3649185301c4a42a2a3465cd">More...</a><br /></td></tr>
<tr class="separator:ac86b7c3c3649185301c4a42a2a3465cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae0d37f7e9b4bed655065e66cc0fe9bd1"><td class="memItemLeft" align="right" valign="top">static String&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae0d37f7e9b4bed655065e66cc0fe9bd1">tmToString</a> (const struct tm *timeptr)</td></tr>
<tr class="memdesc:ae0d37f7e9b4bed655065e66cc0fe9bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to convert a struct tm * to a readable string.  <a href="class_a_b1805.html#ae0d37f7e9b4bed655065e66cc0fe9bd1">More...</a><br /></td></tr>
<tr class="separator:ae0d37f7e9b4bed655065e66cc0fe9bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6673da5d88733e6457f161c9a17f2997"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6673da5d88733e6457f161c9a17f2997">tmToRegisters</a> (const struct tm *timeptr, uint8_t *array, bool includeYear)</td></tr>
<tr class="memdesc:a6673da5d88733e6457f161c9a17f2997"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a struct tm to register values for the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>.  <a href="class_a_b1805.html#a6673da5d88733e6457f161c9a17f2997">More...</a><br /></td></tr>
<tr class="separator:a6673da5d88733e6457f161c9a17f2997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd515347c26486819bebaa92606bff06"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afd515347c26486819bebaa92606bff06">registersToTm</a> (const uint8_t *array, struct tm *timeptr, bool includeYear)</td></tr>
<tr class="memdesc:afd515347c26486819bebaa92606bff06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert register values to a struct tm.  <a href="class_a_b1805.html#afd515347c26486819bebaa92606bff06">More...</a><br /></td></tr>
<tr class="separator:afd515347c26486819bebaa92606bff06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8abd555d3cac4723ce88b0fdc38307"><td class="memItemLeft" align="right" valign="top"><a id="a2c8abd555d3cac4723ce88b0fdc38307"></a>
static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2c8abd555d3cac4723ce88b0fdc38307">bcdToValue</a> (uint8_t bcd)</td></tr>
<tr class="memdesc:a2c8abd555d3cac4723ce88b0fdc38307"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a bcd value (0x00-0x99) into an integer (0-99) <br /></td></tr>
<tr class="separator:a2c8abd555d3cac4723ce88b0fdc38307"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdcce52392c4f13ee73b1f2844f3784e"><td class="memItemLeft" align="right" valign="top"><a id="abdcce52392c4f13ee73b1f2844f3784e"></a>
static uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#abdcce52392c4f13ee73b1f2844f3784e">valueToBcd</a> (int value)</td></tr>
<tr class="memdesc:abdcce52392c4f13ee73b1f2844f3784e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an integer value (0-99) into a bcd value (0x00 - 0x99) <br /></td></tr>
<tr class="separator:abdcce52392c4f13ee73b1f2844f3784e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a74ff2c5a015e40caa05f8ab3bf17f015"><td class="memItemLeft" align="right" valign="top"><a id="a74ff2c5a015e40caa05f8ab3bf17f015"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a74ff2c5a015e40caa05f8ab3bf17f015">RESET_PRESERVE_REPEATING_TIMER</a> = 0x00000001</td></tr>
<tr class="memdesc:a74ff2c5a015e40caa05f8ab3bf17f015"><td class="mdescLeft">&#160;</td><td class="mdescRight">When resetting registers, leave repeating timer settings intact. <br /></td></tr>
<tr class="separator:a74ff2c5a015e40caa05f8ab3bf17f015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d41a8c60278e5e611806e58afc5e93c"><td class="memItemLeft" align="right" valign="top"><a id="a7d41a8c60278e5e611806e58afc5e93c"></a>
static const uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7d41a8c60278e5e611806e58afc5e93c">RESET_DISABLE_XT</a> = 0x00000002</td></tr>
<tr class="memdesc:a7d41a8c60278e5e611806e58afc5e93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When resetting registers, disable XT oscillator. <br /></td></tr>
<tr class="separator:a7d41a8c60278e5e611806e58afc5e93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1655c85fcfd29cda95a7498794505f8"><td class="memItemLeft" align="right" valign="top"><a id="ab1655c85fcfd29cda95a7498794505f8"></a>
static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab1655c85fcfd29cda95a7498794505f8">WATCHDOG_MAX_SECONDS</a> = 124</td></tr>
<tr class="memdesc:ab1655c85fcfd29cda95a7498794505f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum value that can be passed to <a class="el" href="class_a_b1805.html#a889f51cd5a025428c683b2842d9d52ff" title="Set or reset the watchdog timer.">setWDT()</a>. <br /></td></tr>
<tr class="separator:ab1655c85fcfd29cda95a7498794505f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3606b0fbfa5158a3985b86319d6e3137"><td class="memItemLeft" align="right" valign="top"><a id="a3606b0fbfa5158a3985b86319d6e3137"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3606b0fbfa5158a3985b86319d6e3137">REG_HUNDREDTH</a> = 0x00</td></tr>
<tr class="memdesc:a3606b0fbfa5158a3985b86319d6e3137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hundredths of a second, 2 BCD digits. <br /></td></tr>
<tr class="separator:a3606b0fbfa5158a3985b86319d6e3137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fce8d4eceb0a073341ea8751745f73"><td class="memItemLeft" align="right" valign="top"><a id="ac3fce8d4eceb0a073341ea8751745f73"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac3fce8d4eceb0a073341ea8751745f73">REG_SECOND</a> = 0x01</td></tr>
<tr class="memdesc:ac3fce8d4eceb0a073341ea8751745f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seconds, 2 BCD digits, MSB is GP0. <br /></td></tr>
<tr class="separator:ac3fce8d4eceb0a073341ea8751745f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103a099db03461a21b6e73352b43394b"><td class="memItemLeft" align="right" valign="top"><a id="a103a099db03461a21b6e73352b43394b"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a103a099db03461a21b6e73352b43394b">REG_MINUTE</a> = 0x02</td></tr>
<tr class="memdesc:a103a099db03461a21b6e73352b43394b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minutes, 2 BCD digits, MSB is GP1. <br /></td></tr>
<tr class="separator:a103a099db03461a21b6e73352b43394b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ea13a69472e93e4a425d9a10e44d85e"><td class="memItemLeft" align="right" valign="top"><a id="a1ea13a69472e93e4a425d9a10e44d85e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a1ea13a69472e93e4a425d9a10e44d85e">REG_HOUR</a> = 0x03</td></tr>
<tr class="memdesc:a1ea13a69472e93e4a425d9a10e44d85e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hours, GP2, GP3. <br /></td></tr>
<tr class="separator:a1ea13a69472e93e4a425d9a10e44d85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0c678f68afea8d505e7929abd19d711"><td class="memItemLeft" align="right" valign="top"><a id="ac0c678f68afea8d505e7929abd19d711"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac0c678f68afea8d505e7929abd19d711">REG_DATE</a> = 0x04</td></tr>
<tr class="memdesc:ac0c678f68afea8d505e7929abd19d711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Day of month (1-31), 2 BCD digits, GP4, GP5. <br /></td></tr>
<tr class="separator:ac0c678f68afea8d505e7929abd19d711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c52d694ffa70edd476d6e8402fda18"><td class="memItemLeft" align="right" valign="top"><a id="a84c52d694ffa70edd476d6e8402fda18"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a84c52d694ffa70edd476d6e8402fda18">REG_MONTH</a> = 0x05</td></tr>
<tr class="memdesc:a84c52d694ffa70edd476d6e8402fda18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Month (1-12), 2 BCD digits, GP6 - GP8. <br /></td></tr>
<tr class="separator:a84c52d694ffa70edd476d6e8402fda18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed83a6c72cf9f9f57e4444d056f4b33"><td class="memItemLeft" align="right" valign="top"><a id="a9ed83a6c72cf9f9f57e4444d056f4b33"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a9ed83a6c72cf9f9f57e4444d056f4b33">REG_YEAR</a> = 0x06</td></tr>
<tr class="memdesc:a9ed83a6c72cf9f9f57e4444d056f4b33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Year (0-99), 2 BCD digits. <br /></td></tr>
<tr class="separator:a9ed83a6c72cf9f9f57e4444d056f4b33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a815fce27021e5cc7feb1600428646"><td class="memItemLeft" align="right" valign="top"><a id="ab0a815fce27021e5cc7feb1600428646"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab0a815fce27021e5cc7feb1600428646">REG_WEEKDAY</a> = 0x07</td></tr>
<tr class="memdesc:ab0a815fce27021e5cc7feb1600428646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Weekday (0-6), GP9 - GP13. <br /></td></tr>
<tr class="separator:ab0a815fce27021e5cc7feb1600428646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305d3116cec47d7bc84b16bfb2a50b4f"><td class="memItemLeft" align="right" valign="top"><a id="a305d3116cec47d7bc84b16bfb2a50b4f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a305d3116cec47d7bc84b16bfb2a50b4f">REG_HUNDREDTH_ALARM</a> = 0x08</td></tr>
<tr class="memdesc:a305d3116cec47d7bc84b16bfb2a50b4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on hundredths of a second (0-99), 2 BCD digits. <br /></td></tr>
<tr class="separator:a305d3116cec47d7bc84b16bfb2a50b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30df44c782a7aeb81e39a5de80e4487a"><td class="memItemLeft" align="right" valign="top"><a id="a30df44c782a7aeb81e39a5de80e4487a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a30df44c782a7aeb81e39a5de80e4487a">REG_SECOND_ALARM</a> = 0x09</td></tr>
<tr class="memdesc:a30df44c782a7aeb81e39a5de80e4487a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on seconds (0-59), 2 BCD digits, GP14. <br /></td></tr>
<tr class="separator:a30df44c782a7aeb81e39a5de80e4487a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bdffddc5f0a74936dfb58ddb243b68"><td class="memItemLeft" align="right" valign="top"><a id="a16bdffddc5f0a74936dfb58ddb243b68"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a16bdffddc5f0a74936dfb58ddb243b68">REG_MINUTE_ALARM</a> = 0x0a</td></tr>
<tr class="memdesc:a16bdffddc5f0a74936dfb58ddb243b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on minutes (0-59), 2 BCD digits, GP15. <br /></td></tr>
<tr class="separator:a16bdffddc5f0a74936dfb58ddb243b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dcc737afa2da1c7d134b2f89c002fc6"><td class="memItemLeft" align="right" valign="top"><a id="a0dcc737afa2da1c7d134b2f89c002fc6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a0dcc737afa2da1c7d134b2f89c002fc6">REG_HOUR_ALARM</a> = 0x0b</td></tr>
<tr class="memdesc:a0dcc737afa2da1c7d134b2f89c002fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on hour, GP16, GP17. <br /></td></tr>
<tr class="separator:a0dcc737afa2da1c7d134b2f89c002fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca737eab9c1ad7c448fd3650bb8bd27"><td class="memItemLeft" align="right" valign="top"><a id="acca737eab9c1ad7c448fd3650bb8bd27"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#acca737eab9c1ad7c448fd3650bb8bd27">REG_DATE_ALARM</a> = 0x0c</td></tr>
<tr class="memdesc:acca737eab9c1ad7c448fd3650bb8bd27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on date (1-31), 2 BCD digits, GP18-GP19. <br /></td></tr>
<tr class="separator:acca737eab9c1ad7c448fd3650bb8bd27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1aa2bd3f8d302e01bb9446d63df1da"><td class="memItemLeft" align="right" valign="top"><a id="a7a1aa2bd3f8d302e01bb9446d63df1da"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7a1aa2bd3f8d302e01bb9446d63df1da">REG_MONTH_ALARM</a> = 0x0d</td></tr>
<tr class="memdesc:a7a1aa2bd3f8d302e01bb9446d63df1da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on month (1-12). 2 BCD digits, GP20-GP22. <br /></td></tr>
<tr class="separator:a7a1aa2bd3f8d302e01bb9446d63df1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770339e96c2a902e8163012dc1bab60e"><td class="memItemLeft" align="right" valign="top"><a id="a770339e96c2a902e8163012dc1bab60e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a770339e96c2a902e8163012dc1bab60e">REG_WEEKDAY_ALARM</a> = 0x0e</td></tr>
<tr class="memdesc:a770339e96c2a902e8163012dc1bab60e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alarm on day of week (0-6). GP23-GP27. <br /></td></tr>
<tr class="separator:a770339e96c2a902e8163012dc1bab60e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f84a592af953aa1a0f0a89e95641e5"><td class="memItemLeft" align="right" valign="top"><a id="a28f84a592af953aa1a0f0a89e95641e5"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a28f84a592af953aa1a0f0a89e95641e5">REG_STATUS</a> = 0x0f</td></tr>
<tr class="memdesc:a28f84a592af953aa1a0f0a89e95641e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register. <br /></td></tr>
<tr class="separator:a28f84a592af953aa1a0f0a89e95641e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b1713102b71e03796a8a42167ce505"><td class="memItemLeft" align="right" valign="top"><a id="ab5b1713102b71e03796a8a42167ce505"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab5b1713102b71e03796a8a42167ce505">REG_STATUS_CB</a> = 0x80</td></tr>
<tr class="memdesc:ab5b1713102b71e03796a8a42167ce505"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register century bit mask. <br /></td></tr>
<tr class="separator:ab5b1713102b71e03796a8a42167ce505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf0b614c58b1c204a515ecc2131ff74d"><td class="memItemLeft" align="right" valign="top"><a id="acf0b614c58b1c204a515ecc2131ff74d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#acf0b614c58b1c204a515ecc2131ff74d">REG_STATUS_BAT</a> = 0x40</td></tr>
<tr class="memdesc:acf0b614c58b1c204a515ecc2131ff74d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register switched to VBAT bit mask. <br /></td></tr>
<tr class="separator:acf0b614c58b1c204a515ecc2131ff74d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14cb28a514c73d4f809b0429aa887d8f"><td class="memItemLeft" align="right" valign="top"><a id="a14cb28a514c73d4f809b0429aa887d8f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a14cb28a514c73d4f809b0429aa887d8f">REG_STATUS_WDT</a> = 0x20</td></tr>
<tr class="memdesc:a14cb28a514c73d4f809b0429aa887d8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register watchdog timer enabled and triggered bit mask. <br /></td></tr>
<tr class="separator:a14cb28a514c73d4f809b0429aa887d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac986f186623f868e0b87e47dbe203dd8"><td class="memItemLeft" align="right" valign="top"><a id="ac986f186623f868e0b87e47dbe203dd8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac986f186623f868e0b87e47dbe203dd8">REG_STATUS_BL</a> = 0x10</td></tr>
<tr class="memdesc:ac986f186623f868e0b87e47dbe203dd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register battery voltage crossing bit mask. <br /></td></tr>
<tr class="separator:ac986f186623f868e0b87e47dbe203dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e52bf91a7f5d23123e89f97b515e86"><td class="memItemLeft" align="right" valign="top"><a id="a61e52bf91a7f5d23123e89f97b515e86"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a61e52bf91a7f5d23123e89f97b515e86">REG_STATUS_TIM</a> = 0x08</td></tr>
<tr class="memdesc:a61e52bf91a7f5d23123e89f97b515e86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register countdown timer reaches 0 bit mask. <br /></td></tr>
<tr class="separator:a61e52bf91a7f5d23123e89f97b515e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa23a3a46c470472c69543e5c739872"><td class="memItemLeft" align="right" valign="top"><a id="abfa23a3a46c470472c69543e5c739872"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#abfa23a3a46c470472c69543e5c739872">REG_STATUS_ALM</a> = 0x04</td></tr>
<tr class="memdesc:abfa23a3a46c470472c69543e5c739872"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register alarm register match bit mask. <br /></td></tr>
<tr class="separator:abfa23a3a46c470472c69543e5c739872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d08c0e7d99f4bc7945a8e8eb13ca85"><td class="memItemLeft" align="right" valign="top"><a id="a22d08c0e7d99f4bc7945a8e8eb13ca85"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a22d08c0e7d99f4bc7945a8e8eb13ca85">REG_STATUS_EX2</a> = 0x02</td></tr>
<tr class="memdesc:a22d08c0e7d99f4bc7945a8e8eb13ca85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register WDI interrupt bit mask. <br /></td></tr>
<tr class="separator:a22d08c0e7d99f4bc7945a8e8eb13ca85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14b9261bd362b29ab740dc623f996de"><td class="memItemLeft" align="right" valign="top"><a id="aa14b9261bd362b29ab740dc623f996de"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa14b9261bd362b29ab740dc623f996de">REG_STATUS_EX1</a> = 0x01</td></tr>
<tr class="memdesc:aa14b9261bd362b29ab740dc623f996de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register EXTI interrupt bit mask. <br /></td></tr>
<tr class="separator:aa14b9261bd362b29ab740dc623f996de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3c616a48f7f1ca583c18d7a0830410"><td class="memItemLeft" align="right" valign="top"><a id="aef3c616a48f7f1ca583c18d7a0830410"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aef3c616a48f7f1ca583c18d7a0830410">REG_STATUS_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:aef3c616a48f7f1ca583c18d7a0830410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status register, default. <br /></td></tr>
<tr class="separator:aef3c616a48f7f1ca583c18d7a0830410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a131e53e3aba4e595038bc8b644c6515d"><td class="memItemLeft" align="right" valign="top"><a id="a131e53e3aba4e595038bc8b644c6515d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a131e53e3aba4e595038bc8b644c6515d">REG_CTRL_1</a> = 0x10</td></tr>
<tr class="memdesc:a131e53e3aba4e595038bc8b644c6515d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1. <br /></td></tr>
<tr class="separator:a131e53e3aba4e595038bc8b644c6515d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483169f667bc6c36e2838754f613b02a"><td class="memItemLeft" align="right" valign="top"><a id="a483169f667bc6c36e2838754f613b02a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a483169f667bc6c36e2838754f613b02a">REG_CTRL_1_STOP</a> = 0x80</td></tr>
<tr class="memdesc:a483169f667bc6c36e2838754f613b02a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, stop clocking system. <br /></td></tr>
<tr class="separator:a483169f667bc6c36e2838754f613b02a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fd90659af43905d431583f6c2bf3248"><td class="memItemLeft" align="right" valign="top"><a id="a5fd90659af43905d431583f6c2bf3248"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5fd90659af43905d431583f6c2bf3248">REG_CTRL_1_12_24</a> = 0x40</td></tr>
<tr class="memdesc:a5fd90659af43905d431583f6c2bf3248"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, 12/24 hour mode select (0 = 24 hour) <br /></td></tr>
<tr class="separator:a5fd90659af43905d431583f6c2bf3248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f10113e669214b0d9bc3bda279c0ce8"><td class="memItemLeft" align="right" valign="top"><a id="a3f10113e669214b0d9bc3bda279c0ce8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3f10113e669214b0d9bc3bda279c0ce8">REG_CTRL_1_OUTB</a> = 0x20</td></tr>
<tr class="memdesc:a3f10113e669214b0d9bc3bda279c0ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, value for nIRQ2. <br /></td></tr>
<tr class="separator:a3f10113e669214b0d9bc3bda279c0ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165f4e0579237f58160b2b703c4df844"><td class="memItemLeft" align="right" valign="top"><a id="a165f4e0579237f58160b2b703c4df844"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a165f4e0579237f58160b2b703c4df844">REG_CTRL_1_OUT</a> = 0x10</td></tr>
<tr class="memdesc:a165f4e0579237f58160b2b703c4df844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, value for FOUT/nIRQ. <br /></td></tr>
<tr class="separator:a165f4e0579237f58160b2b703c4df844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d7597e70b3dbaf63ed3dcff00b5f0d"><td class="memItemLeft" align="right" valign="top"><a id="ae0d7597e70b3dbaf63ed3dcff00b5f0d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae0d7597e70b3dbaf63ed3dcff00b5f0d">REG_CTRL_1_RSP</a> = 0x08</td></tr>
<tr class="memdesc:ae0d7597e70b3dbaf63ed3dcff00b5f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, Reset polarity. <br /></td></tr>
<tr class="separator:ae0d7597e70b3dbaf63ed3dcff00b5f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dca6e781f5c376a0fe21e7338a16d7"><td class="memItemLeft" align="right" valign="top"><a id="ac7dca6e781f5c376a0fe21e7338a16d7"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac7dca6e781f5c376a0fe21e7338a16d7">REG_CTRL_1_ARST</a> = 0x04</td></tr>
<tr class="memdesc:ac7dca6e781f5c376a0fe21e7338a16d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, Auto reset enable. <br /></td></tr>
<tr class="separator:ac7dca6e781f5c376a0fe21e7338a16d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa26f7ad4a82e9adf693c8cdf1d447428"><td class="memItemLeft" align="right" valign="top"><a id="aa26f7ad4a82e9adf693c8cdf1d447428"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa26f7ad4a82e9adf693c8cdf1d447428">REG_CTRL_1_PWR2</a> = 0x02</td></tr>
<tr class="memdesc:aa26f7ad4a82e9adf693c8cdf1d447428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, PWW/nIRQ pull-down enable. <br /></td></tr>
<tr class="separator:aa26f7ad4a82e9adf693c8cdf1d447428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a681a0d7ff531e4f9a64cfefae787bde4"><td class="memItemLeft" align="right" valign="top"><a id="a681a0d7ff531e4f9a64cfefae787bde4"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a681a0d7ff531e4f9a64cfefae787bde4">REG_CTRL_1_WRTC</a> = 0x01</td></tr>
<tr class="memdesc:a681a0d7ff531e4f9a64cfefae787bde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, write RTC mode. <br /></td></tr>
<tr class="separator:a681a0d7ff531e4f9a64cfefae787bde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f117c3207fc7ceb2b376ef56582032"><td class="memItemLeft" align="right" valign="top"><a id="aa6f117c3207fc7ceb2b376ef56582032"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa6f117c3207fc7ceb2b376ef56582032">REG_CTRL_1_DEFAULT</a> = 0x13</td></tr>
<tr class="memdesc:aa6f117c3207fc7ceb2b376ef56582032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 1, 0b00010011 (OUT | RSO | PWR2 | WRTC) <br /></td></tr>
<tr class="separator:aa6f117c3207fc7ceb2b376ef56582032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66cc158575aafffa1e3df58b9ab7b0e4"><td class="memItemLeft" align="right" valign="top"><a id="a66cc158575aafffa1e3df58b9ab7b0e4"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a66cc158575aafffa1e3df58b9ab7b0e4">REG_CTRL_2</a> = 0x11</td></tr>
<tr class="memdesc:a66cc158575aafffa1e3df58b9ab7b0e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2. <br /></td></tr>
<tr class="separator:a66cc158575aafffa1e3df58b9ab7b0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51dd5f85bbda57f3f9f9d4637d1efb15"><td class="memItemLeft" align="right" valign="top"><a id="a51dd5f85bbda57f3f9f9d4637d1efb15"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a51dd5f85bbda57f3f9f9d4637d1efb15">REG_CTRL_2_RS1E</a> = 0x20</td></tr>
<tr class="memdesc:a51dd5f85bbda57f3f9f9d4637d1efb15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode. <br /></td></tr>
<tr class="separator:a51dd5f85bbda57f3f9f9d4637d1efb15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a95fea411ddac70c04389e96bf1439"><td class="memItemLeft" align="right" valign="top"><a id="a30a95fea411ddac70c04389e96bf1439"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a30a95fea411ddac70c04389e96bf1439">REG_CTRL_2_OUT2S_MASK</a> = 0x1c</td></tr>
<tr class="memdesc:a30a95fea411ddac70c04389e96bf1439"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode. <br /></td></tr>
<tr class="separator:a30a95fea411ddac70c04389e96bf1439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7515be87b3e34b9bf1d4844c182df9f"><td class="memItemLeft" align="right" valign="top"><a id="ae7515be87b3e34b9bf1d4844c182df9f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae7515be87b3e34b9bf1d4844c182df9f">REG_CTRL_2_OUT2S_nIRQ</a> = 0x00</td></tr>
<tr class="memdesc:ae7515be87b3e34b9bf1d4844c182df9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, nIRQ or OUTB. <br /></td></tr>
<tr class="separator:ae7515be87b3e34b9bf1d4844c182df9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add020fcd98a67a95d595c4c4805e029a"><td class="memItemLeft" align="right" valign="top"><a id="add020fcd98a67a95d595c4c4805e029a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#add020fcd98a67a95d595c4c4805e029a">REG_CTRL_2_OUT2S_SQW</a> = 0x04</td></tr>
<tr class="memdesc:add020fcd98a67a95d595c4c4805e029a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, SQW or OUTB. <br /></td></tr>
<tr class="separator:add020fcd98a67a95d595c4c4805e029a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa102b19dc02e2b346a02daa0c4eb2f77"><td class="memItemLeft" align="right" valign="top"><a id="aa102b19dc02e2b346a02daa0c4eb2f77"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa102b19dc02e2b346a02daa0c4eb2f77">REG_CTRL_2_OUT2S_nAIRQ</a> = 0x0c</td></tr>
<tr class="memdesc:aa102b19dc02e2b346a02daa0c4eb2f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, nAIRQ or OUTB. <br /></td></tr>
<tr class="separator:aa102b19dc02e2b346a02daa0c4eb2f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fc9f364ff3de883ef4ae38637ecf1a"><td class="memItemLeft" align="right" valign="top"><a id="a79fc9f364ff3de883ef4ae38637ecf1a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a79fc9f364ff3de883ef4ae38637ecf1a">REG_CTRL_2_OUT2S_TIRQ</a> = 0x10</td></tr>
<tr class="memdesc:a79fc9f364ff3de883ef4ae38637ecf1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, TIRQ or OUTB. <br /></td></tr>
<tr class="separator:a79fc9f364ff3de883ef4ae38637ecf1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acddc837e0156c6890edd73e8525b4b2f"><td class="memItemLeft" align="right" valign="top"><a id="acddc837e0156c6890edd73e8525b4b2f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#acddc837e0156c6890edd73e8525b4b2f">REG_CTRL_2_OUT2S_nTIRQ</a> = 0x14</td></tr>
<tr class="memdesc:acddc837e0156c6890edd73e8525b4b2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, nTIRQ or OUTB. <br /></td></tr>
<tr class="separator:acddc837e0156c6890edd73e8525b4b2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc8e3f6661a2b2009f7303b652124cf"><td class="memItemLeft" align="right" valign="top"><a id="a0cc8e3f6661a2b2009f7303b652124cf"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a0cc8e3f6661a2b2009f7303b652124cf">REG_CTRL_2_OUT2S_SLEEP</a> = 0x18</td></tr>
<tr class="memdesc:a0cc8e3f6661a2b2009f7303b652124cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, sleep mode. <br /></td></tr>
<tr class="separator:a0cc8e3f6661a2b2009f7303b652124cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39085ad678004d6cfe331b62f4793706"><td class="memItemLeft" align="right" valign="top"><a id="a39085ad678004d6cfe331b62f4793706"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a39085ad678004d6cfe331b62f4793706">REG_CTRL_2_OUT2S_OUTB</a> = 0x1c</td></tr>
<tr class="memdesc:a39085ad678004d6cfe331b62f4793706"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, nIRQ2 output mode, OUTB. <br /></td></tr>
<tr class="separator:a39085ad678004d6cfe331b62f4793706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac143743e412e3d24a8614f4f0497d33e"><td class="memItemLeft" align="right" valign="top"><a id="ac143743e412e3d24a8614f4f0497d33e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac143743e412e3d24a8614f4f0497d33e">REG_CTRL_2_OUT1S_MASK</a> = 0x03</td></tr>
<tr class="memdesc:ac143743e412e3d24a8614f4f0497d33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, FOUT/nIRQ output mode. <br /></td></tr>
<tr class="separator:ac143743e412e3d24a8614f4f0497d33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8175652e32f226a71b68be8b7d0966c4"><td class="memItemLeft" align="right" valign="top"><a id="a8175652e32f226a71b68be8b7d0966c4"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8175652e32f226a71b68be8b7d0966c4">REG_CTRL_2_OUT1S_nIRQ</a> = 0x00</td></tr>
<tr class="memdesc:a8175652e32f226a71b68be8b7d0966c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, FOUT/nIRQ output mode, nIRQ, or OUT. <br /></td></tr>
<tr class="separator:a8175652e32f226a71b68be8b7d0966c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e3d3927bbd2fef7f6c5d87e361d883"><td class="memItemLeft" align="right" valign="top"><a id="a70e3d3927bbd2fef7f6c5d87e361d883"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a70e3d3927bbd2fef7f6c5d87e361d883">REG_CTRL_2_OUT1S_SQW</a> = 0x01</td></tr>
<tr class="memdesc:a70e3d3927bbd2fef7f6c5d87e361d883"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, FOUT/nIRQ output mode, SQW or OUT. <br /></td></tr>
<tr class="separator:a70e3d3927bbd2fef7f6c5d87e361d883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89cb7330240a7ef112160b3239f9457"><td class="memItemLeft" align="right" valign="top"><a id="aa89cb7330240a7ef112160b3239f9457"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa89cb7330240a7ef112160b3239f9457">REG_CTRL_2_OUT1S_SQW_nIRQ</a> = 0x02</td></tr>
<tr class="memdesc:aa89cb7330240a7ef112160b3239f9457"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, FOUT/nIRQ output mode, SQW, nIRQ, or OUT. <br /></td></tr>
<tr class="separator:aa89cb7330240a7ef112160b3239f9457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bc8132e71162a4d80d1cdf725fd9483"><td class="memItemLeft" align="right" valign="top"><a id="a2bc8132e71162a4d80d1cdf725fd9483"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2bc8132e71162a4d80d1cdf725fd9483">REG_CTRL_2_OUT1S_nAIRQ</a> = 0x03</td></tr>
<tr class="memdesc:a2bc8132e71162a4d80d1cdf725fd9483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, FOUT/nIRQ output mode, nIRQ or OUT. <br /></td></tr>
<tr class="separator:a2bc8132e71162a4d80d1cdf725fd9483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f6ec668fe6858399d089d6c7c31d53a"><td class="memItemLeft" align="right" valign="top"><a id="a5f6ec668fe6858399d089d6c7c31d53a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5f6ec668fe6858399d089d6c7c31d53a">REG_CTRL_2_DEFAULT</a> = 0x3c</td></tr>
<tr class="memdesc:a5f6ec668fe6858399d089d6c7c31d53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Control register 2, 0b00111100 (OUT2S = OUTB) <br /></td></tr>
<tr class="separator:a5f6ec668fe6858399d089d6c7c31d53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158f3f666036e6f5a85022123c25a9d8"><td class="memItemLeft" align="right" valign="top"><a id="a158f3f666036e6f5a85022123c25a9d8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a158f3f666036e6f5a85022123c25a9d8">REG_INT_MASK</a> = 0x12</td></tr>
<tr class="memdesc:a158f3f666036e6f5a85022123c25a9d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask. <br /></td></tr>
<tr class="separator:a158f3f666036e6f5a85022123c25a9d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea166c27255f91dfa9ab1bca66663d0"><td class="memItemLeft" align="right" valign="top"><a id="a4ea166c27255f91dfa9ab1bca66663d0"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a4ea166c27255f91dfa9ab1bca66663d0">REG_INT_MASK_CEB</a> = 0x80</td></tr>
<tr class="memdesc:a4ea166c27255f91dfa9ab1bca66663d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, century enable. <br /></td></tr>
<tr class="separator:a4ea166c27255f91dfa9ab1bca66663d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6bbcb042c72aa3c0f8d8586aa4c7948"><td class="memItemLeft" align="right" valign="top"><a id="aa6bbcb042c72aa3c0f8d8586aa4c7948"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa6bbcb042c72aa3c0f8d8586aa4c7948">REG_INT_MASK_IM</a> = 0x60</td></tr>
<tr class="memdesc:aa6bbcb042c72aa3c0f8d8586aa4c7948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, interrupt mode bits (2 bits) <br /></td></tr>
<tr class="separator:aa6bbcb042c72aa3c0f8d8586aa4c7948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d73759b8ede067cc7d92e61ea326ef7"><td class="memItemLeft" align="right" valign="top"><a id="a5d73759b8ede067cc7d92e61ea326ef7"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5d73759b8ede067cc7d92e61ea326ef7">REG_INT_MASK_BLIE</a> = 0x10</td></tr>
<tr class="memdesc:a5d73759b8ede067cc7d92e61ea326ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, battery low interrupt enable. <br /></td></tr>
<tr class="separator:a5d73759b8ede067cc7d92e61ea326ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42d1a1e9396871b8a32bd83b9c2c947"><td class="memItemLeft" align="right" valign="top"><a id="ac42d1a1e9396871b8a32bd83b9c2c947"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac42d1a1e9396871b8a32bd83b9c2c947">REG_INT_MASK_TIE</a> = 0x08</td></tr>
<tr class="memdesc:ac42d1a1e9396871b8a32bd83b9c2c947"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, timer interrupt enable. <br /></td></tr>
<tr class="separator:ac42d1a1e9396871b8a32bd83b9c2c947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed9abc81e1808cd13f7f221a7fdb6d9"><td class="memItemLeft" align="right" valign="top"><a id="a7ed9abc81e1808cd13f7f221a7fdb6d9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7ed9abc81e1808cd13f7f221a7fdb6d9">REG_INT_MASK_AIE</a> = 0x04</td></tr>
<tr class="memdesc:a7ed9abc81e1808cd13f7f221a7fdb6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, alarm interrupt enable. <br /></td></tr>
<tr class="separator:a7ed9abc81e1808cd13f7f221a7fdb6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d2ba60a7f0170a7e813cef676963c9"><td class="memItemLeft" align="right" valign="top"><a id="ac9d2ba60a7f0170a7e813cef676963c9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac9d2ba60a7f0170a7e813cef676963c9">REG_INT_MASK_EX2E</a> = 0x02</td></tr>
<tr class="memdesc:ac9d2ba60a7f0170a7e813cef676963c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, XT2 interrupt enable. <br /></td></tr>
<tr class="separator:ac9d2ba60a7f0170a7e813cef676963c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaebcc16ef37890559e9a39c4153ff272"><td class="memItemLeft" align="right" valign="top"><a id="aaebcc16ef37890559e9a39c4153ff272"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aaebcc16ef37890559e9a39c4153ff272">REG_INT_MASK_EX1E</a> = 0x01</td></tr>
<tr class="memdesc:aaebcc16ef37890559e9a39c4153ff272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, XT1 interrupt enable. <br /></td></tr>
<tr class="separator:aaebcc16ef37890559e9a39c4153ff272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b895f0ac37abdc1471a1ce57626c64f"><td class="memItemLeft" align="right" valign="top"><a id="a3b895f0ac37abdc1471a1ce57626c64f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3b895f0ac37abdc1471a1ce57626c64f">REG_INT_MASK_DEFAULT</a> = 0xe0</td></tr>
<tr class="memdesc:a3b895f0ac37abdc1471a1ce57626c64f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt mask, default 0b11100000 (CEB | IM=1/4 seconds) <br /></td></tr>
<tr class="separator:a3b895f0ac37abdc1471a1ce57626c64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac79d14a8090c7400e0db405750419a"><td class="memItemLeft" align="right" valign="top"><a id="adac79d14a8090c7400e0db405750419a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#adac79d14a8090c7400e0db405750419a">REG_SQW</a> = 0x13</td></tr>
<tr class="memdesc:adac79d14a8090c7400e0db405750419a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square wave output control. <br /></td></tr>
<tr class="separator:adac79d14a8090c7400e0db405750419a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6138828c12cb790acc6330e751a4f03"><td class="memItemLeft" align="right" valign="top"><a id="aa6138828c12cb790acc6330e751a4f03"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa6138828c12cb790acc6330e751a4f03">REG_SQW_SQWE</a> = 0x80</td></tr>
<tr class="memdesc:aa6138828c12cb790acc6330e751a4f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square wave output control, enable. <br /></td></tr>
<tr class="separator:aa6138828c12cb790acc6330e751a4f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34423376f31cf9618c5a88d4121ce9bc"><td class="memItemLeft" align="right" valign="top"><a id="a34423376f31cf9618c5a88d4121ce9bc"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a34423376f31cf9618c5a88d4121ce9bc">REG_SQW_DEFAULT</a> = 0x26</td></tr>
<tr class="memdesc:a34423376f31cf9618c5a88d4121ce9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Square wave output control, default 0b00100110. <br /></td></tr>
<tr class="separator:a34423376f31cf9618c5a88d4121ce9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c3d9251bcf78e7b70780ef656f4500"><td class="memItemLeft" align="right" valign="top"><a id="ad5c3d9251bcf78e7b70780ef656f4500"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ad5c3d9251bcf78e7b70780ef656f4500">REG_CAL_XT</a> = 0x14</td></tr>
<tr class="memdesc:ad5c3d9251bcf78e7b70780ef656f4500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration for the XT oscillator. <br /></td></tr>
<tr class="separator:ad5c3d9251bcf78e7b70780ef656f4500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13320d37c0c31fca6e994542d3ffa6d"><td class="memItemLeft" align="right" valign="top"><a id="ac13320d37c0c31fca6e994542d3ffa6d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac13320d37c0c31fca6e994542d3ffa6d">REG_CAL_RC_HIGH</a> = 0x15</td></tr>
<tr class="memdesc:ac13320d37c0c31fca6e994542d3ffa6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration for the RC oscillator, upper 8 bits. <br /></td></tr>
<tr class="separator:ac13320d37c0c31fca6e994542d3ffa6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231d5e6ddd05e1d3a437d8327ce10134"><td class="memItemLeft" align="right" valign="top"><a id="a231d5e6ddd05e1d3a437d8327ce10134"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a231d5e6ddd05e1d3a437d8327ce10134">REG_CAL_RC_LOW</a> = 0x16</td></tr>
<tr class="memdesc:a231d5e6ddd05e1d3a437d8327ce10134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calibration for the RC oscillator, lower 8 bits. <br /></td></tr>
<tr class="separator:a231d5e6ddd05e1d3a437d8327ce10134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4946c5a26fa753eecb2cba2d5cb64c4"><td class="memItemLeft" align="right" valign="top"><a id="aa4946c5a26fa753eecb2cba2d5cb64c4"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa4946c5a26fa753eecb2cba2d5cb64c4">REG_SLEEP_CTRL</a> = 0x17</td></tr>
<tr class="memdesc:aa4946c5a26fa753eecb2cba2d5cb64c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Power control system sleep function. <br /></td></tr>
<tr class="separator:aa4946c5a26fa753eecb2cba2d5cb64c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b33c170f46625a86179f3493d441909"><td class="memItemLeft" align="right" valign="top"><a id="a4b33c170f46625a86179f3493d441909"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a4b33c170f46625a86179f3493d441909">REG_SLEEP_CTRL_SLP</a> = 0x80</td></tr>
<tr class="memdesc:a4b33c170f46625a86179f3493d441909"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control, enter sleep mode. <br /></td></tr>
<tr class="separator:a4b33c170f46625a86179f3493d441909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a6bec2d30c2cb3e2ae8ffdb40c848b"><td class="memItemLeft" align="right" valign="top"><a id="a39a6bec2d30c2cb3e2ae8ffdb40c848b"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a39a6bec2d30c2cb3e2ae8ffdb40c848b">REG_SLEEP_CTRL_SLRES</a> = 0x40</td></tr>
<tr class="memdesc:a39a6bec2d30c2cb3e2ae8ffdb40c848b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control, nRST low on sleep. <br /></td></tr>
<tr class="separator:a39a6bec2d30c2cb3e2ae8ffdb40c848b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e84ce4afbe415386cb172abfb96acff"><td class="memItemLeft" align="right" valign="top"><a id="a7e84ce4afbe415386cb172abfb96acff"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7e84ce4afbe415386cb172abfb96acff">REG_SLEEP_CTRL_EX2P</a> = 0x20</td></tr>
<tr class="memdesc:a7e84ce4afbe415386cb172abfb96acff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control, XT2 on rising WDI. <br /></td></tr>
<tr class="separator:a7e84ce4afbe415386cb172abfb96acff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16200d82b714d601e97a24087a66c8c"><td class="memItemLeft" align="right" valign="top"><a id="ae16200d82b714d601e97a24087a66c8c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae16200d82b714d601e97a24087a66c8c">REG_SLEEP_CTRL_EX1P</a> = 0x10</td></tr>
<tr class="memdesc:ae16200d82b714d601e97a24087a66c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control, XT1 on rising EXTI. <br /></td></tr>
<tr class="separator:ae16200d82b714d601e97a24087a66c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f6b0f59fce6a5c3137ce94ebdbc403"><td class="memItemLeft" align="right" valign="top"><a id="a59f6b0f59fce6a5c3137ce94ebdbc403"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a59f6b0f59fce6a5c3137ce94ebdbc403">REG_SLEEP_CTRL_SLST</a> = 0x08</td></tr>
<tr class="memdesc:a59f6b0f59fce6a5c3137ce94ebdbc403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control, set when sleep has occurred. <br /></td></tr>
<tr class="separator:a59f6b0f59fce6a5c3137ce94ebdbc403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99c54b283ecce627f2e5bd0a8580948c"><td class="memItemLeft" align="right" valign="top"><a id="a99c54b283ecce627f2e5bd0a8580948c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a99c54b283ecce627f2e5bd0a8580948c">REG_SLEEP_CTRL_SLTO_MASK</a> = 0x07</td></tr>
<tr class="memdesc:a99c54b283ecce627f2e5bd0a8580948c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control, number of 7.8ms periods before sleep. <br /></td></tr>
<tr class="separator:a99c54b283ecce627f2e5bd0a8580948c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f85599d57de0897ef7bb4f93f9f3bab"><td class="memItemLeft" align="right" valign="top"><a id="a7f85599d57de0897ef7bb4f93f9f3bab"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a7f85599d57de0897ef7bb4f93f9f3bab">REG_SLEEP_CTRL_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:a7f85599d57de0897ef7bb4f93f9f3bab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sleep control default (0b00000000) <br /></td></tr>
<tr class="separator:a7f85599d57de0897ef7bb4f93f9f3bab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d831c9a5c9ec5a206c6b65f6edd1191"><td class="memItemLeft" align="right" valign="top"><a id="a3d831c9a5c9ec5a206c6b65f6edd1191"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3d831c9a5c9ec5a206c6b65f6edd1191">REG_TIMER_CTRL</a> = 0x18</td></tr>
<tr class="memdesc:a3d831c9a5c9ec5a206c6b65f6edd1191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control. <br /></td></tr>
<tr class="separator:a3d831c9a5c9ec5a206c6b65f6edd1191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4620425a6f397c174b8947373c3ce8"><td class="memItemLeft" align="right" valign="top"><a id="a4d4620425a6f397c174b8947373c3ce8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a4d4620425a6f397c174b8947373c3ce8">REG_TIMER_CTRL_TE</a> = 0x80</td></tr>
<tr class="memdesc:a4d4620425a6f397c174b8947373c3ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, timer enable. <br /></td></tr>
<tr class="separator:a4d4620425a6f397c174b8947373c3ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ab988ba0376a945904c200c0ff3c39"><td class="memItemLeft" align="right" valign="top"><a id="a73ab988ba0376a945904c200c0ff3c39"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a73ab988ba0376a945904c200c0ff3c39">REG_TIMER_CTRL_TM</a> = 0x40</td></tr>
<tr class="memdesc:a73ab988ba0376a945904c200c0ff3c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, timer interrupt mode. <br /></td></tr>
<tr class="separator:a73ab988ba0376a945904c200c0ff3c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c77a75b89fe16fab8cce638d97d3ef0"><td class="memItemLeft" align="right" valign="top"><a id="a8c77a75b89fe16fab8cce638d97d3ef0"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8c77a75b89fe16fab8cce638d97d3ef0">REG_TIMER_CTRL_TRPT</a> = 0x20</td></tr>
<tr class="memdesc:a8c77a75b89fe16fab8cce638d97d3ef0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, timer repeat function. <br /></td></tr>
<tr class="separator:a8c77a75b89fe16fab8cce638d97d3ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f3728e77b593816384ff4c307f8385"><td class="memItemLeft" align="right" valign="top"><a id="a79f3728e77b593816384ff4c307f8385"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a79f3728e77b593816384ff4c307f8385">REG_TIMER_CTRL_RPT_MASK</a> = 0x1c</td></tr>
<tr class="memdesc:a79f3728e77b593816384ff4c307f8385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat function. <br /></td></tr>
<tr class="separator:a79f3728e77b593816384ff4c307f8385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2667cc88a48aa299351ebb7a9050a76e"><td class="memItemLeft" align="right" valign="top"><a id="a2667cc88a48aa299351ebb7a9050a76e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2667cc88a48aa299351ebb7a9050a76e">REG_TIMER_CTRL_RPT_HUN</a> = 0x1c</td></tr>
<tr class="memdesc:a2667cc88a48aa299351ebb7a9050a76e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths match (7) <br /></td></tr>
<tr class="separator:a2667cc88a48aa299351ebb7a9050a76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60a51f74b413843f73bfeaab403f220b"><td class="memItemLeft" align="right" valign="top"><a id="a60a51f74b413843f73bfeaab403f220b"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a60a51f74b413843f73bfeaab403f220b">REG_TIMER_CTRL_RPT_SEC</a> = 0x18</td></tr>
<tr class="memdesc:a60a51f74b413843f73bfeaab403f220b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths, seconds match (once per minute) (6) <br /></td></tr>
<tr class="separator:a60a51f74b413843f73bfeaab403f220b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab959ab2cfd51fe7ffad5e40c8f0527ee"><td class="memItemLeft" align="right" valign="top"><a id="ab959ab2cfd51fe7ffad5e40c8f0527ee"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab959ab2cfd51fe7ffad5e40c8f0527ee">REG_TIMER_CTRL_RPT_MIN</a> = 0x14</td></tr>
<tr class="memdesc:ab959ab2cfd51fe7ffad5e40c8f0527ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths, seconds, minutes match (once per hour) (5) <br /></td></tr>
<tr class="separator:ab959ab2cfd51fe7ffad5e40c8f0527ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47d90ded29360494a5b18e3ff74e966"><td class="memItemLeft" align="right" valign="top"><a id="af47d90ded29360494a5b18e3ff74e966"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#af47d90ded29360494a5b18e3ff74e966">REG_TIMER_CTRL_RPT_HOUR</a> = 0x10</td></tr>
<tr class="memdesc:af47d90ded29360494a5b18e3ff74e966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths, seconds, minutes, hours match (once per day) (4) <br /></td></tr>
<tr class="separator:af47d90ded29360494a5b18e3ff74e966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe8e3d1ca902ae8a4b1565fdeb9ee97"><td class="memItemLeft" align="right" valign="top"><a id="adbe8e3d1ca902ae8a4b1565fdeb9ee97"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#adbe8e3d1ca902ae8a4b1565fdeb9ee97">REG_TIMER_CTRL_RPT_WKDY</a> = 0x0c</td></tr>
<tr class="memdesc:adbe8e3d1ca902ae8a4b1565fdeb9ee97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths, seconds, minutes, hours, weekday match (once per week) (3) <br /></td></tr>
<tr class="separator:adbe8e3d1ca902ae8a4b1565fdeb9ee97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b1b42cb6df8e4ec127a654e2f52c1c"><td class="memItemLeft" align="right" valign="top"><a id="a60b1b42cb6df8e4ec127a654e2f52c1c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a60b1b42cb6df8e4ec127a654e2f52c1c">REG_TIMER_CTRL_RPT_DATE</a> = 0x08</td></tr>
<tr class="memdesc:a60b1b42cb6df8e4ec127a654e2f52c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths, seconds, minutes, hours, date match (once per month) (2) <br /></td></tr>
<tr class="separator:a60b1b42cb6df8e4ec127a654e2f52c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366d268a15f58f0307a2c21b60bd51f6"><td class="memItemLeft" align="right" valign="top"><a id="a366d268a15f58f0307a2c21b60bd51f6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a366d268a15f58f0307a2c21b60bd51f6">REG_TIMER_CTRL_RPT_MON</a> = 0x04</td></tr>
<tr class="memdesc:a366d268a15f58f0307a2c21b60bd51f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, repeat hundredths, seconds, minutes, hours, date, month match (once per year) (1) <br /></td></tr>
<tr class="separator:a366d268a15f58f0307a2c21b60bd51f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6fc0455ef94d16afd1f662e2e3bdc9"><td class="memItemLeft" align="right" valign="top"><a id="acd6fc0455ef94d16afd1f662e2e3bdc9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#acd6fc0455ef94d16afd1f662e2e3bdc9">REG_TIMER_CTRL_RPT_DIS</a> = 0x00</td></tr>
<tr class="memdesc:acd6fc0455ef94d16afd1f662e2e3bdc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, alarm disabled (0) <br /></td></tr>
<tr class="separator:acd6fc0455ef94d16afd1f662e2e3bdc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bd07d819372170765ba500d139ea5a"><td class="memItemLeft" align="right" valign="top"><a id="a10bd07d819372170765ba500d139ea5a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a10bd07d819372170765ba500d139ea5a">REG_TIMER_CTRL_TFS_MASK</a> = 0x03</td></tr>
<tr class="memdesc:a10bd07d819372170765ba500d139ea5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, clock frequency. <br /></td></tr>
<tr class="separator:a10bd07d819372170765ba500d139ea5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96329463de5b5de67d0a9b07cc7cf1c9"><td class="memItemLeft" align="right" valign="top"><a id="a96329463de5b5de67d0a9b07cc7cf1c9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a96329463de5b5de67d0a9b07cc7cf1c9">REG_TIMER_CTRL_TFS_FAST</a> = 0x00</td></tr>
<tr class="memdesc:a96329463de5b5de67d0a9b07cc7cf1c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, clock frequency 4.096 kHz or 128 Hz. <br /></td></tr>
<tr class="separator:a96329463de5b5de67d0a9b07cc7cf1c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd86c692456814de020adec768d96b3"><td class="memItemLeft" align="right" valign="top"><a id="afdd86c692456814de020adec768d96b3"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afdd86c692456814de020adec768d96b3">REG_TIMER_CTRL_TFS_64</a> = 0x01</td></tr>
<tr class="memdesc:afdd86c692456814de020adec768d96b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, clock frequency 64 Hz. <br /></td></tr>
<tr class="separator:afdd86c692456814de020adec768d96b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c93e4491dacb20209c5cff192ba2fc"><td class="memItemLeft" align="right" valign="top"><a id="aa0c93e4491dacb20209c5cff192ba2fc"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa0c93e4491dacb20209c5cff192ba2fc">REG_TIMER_CTRL_TFS_1</a> = 0x02</td></tr>
<tr class="memdesc:aa0c93e4491dacb20209c5cff192ba2fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, clock frequency 1 Hz. <br /></td></tr>
<tr class="separator:aa0c93e4491dacb20209c5cff192ba2fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac731392dc74d6dc6fa9d877a9537e485"><td class="memItemLeft" align="right" valign="top"><a id="ac731392dc74d6dc6fa9d877a9537e485"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac731392dc74d6dc6fa9d877a9537e485">REG_TIMER_CTRL_TFS_1_60</a> = 0x03</td></tr>
<tr class="memdesc:ac731392dc74d6dc6fa9d877a9537e485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, clock frequency 1/60 Hz (1 minute) <br /></td></tr>
<tr class="separator:ac731392dc74d6dc6fa9d877a9537e485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae78df88e1a49c91416c817dcd7a83cde"><td class="memItemLeft" align="right" valign="top"><a id="ae78df88e1a49c91416c817dcd7a83cde"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae78df88e1a49c91416c817dcd7a83cde">REG_TIMER_CTRL_DEFAULT</a> = 0x23</td></tr>
<tr class="memdesc:ae78df88e1a49c91416c817dcd7a83cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer control, 0b00100011 (TFPT + TFS = 1/60 Hz0) <br /></td></tr>
<tr class="separator:ae78df88e1a49c91416c817dcd7a83cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bdd0d5c3d02f62c46f20cd25a46e09"><td class="memItemLeft" align="right" valign="top"><a id="a26bdd0d5c3d02f62c46f20cd25a46e09"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a26bdd0d5c3d02f62c46f20cd25a46e09">REG_TIMER</a> = 0x19</td></tr>
<tr class="memdesc:a26bdd0d5c3d02f62c46f20cd25a46e09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer current value register. <br /></td></tr>
<tr class="separator:a26bdd0d5c3d02f62c46f20cd25a46e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f883ec74ea96fba44704b6d29f5c01"><td class="memItemLeft" align="right" valign="top"><a id="a05f883ec74ea96fba44704b6d29f5c01"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a05f883ec74ea96fba44704b6d29f5c01">REG_TIMER_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:a05f883ec74ea96fba44704b6d29f5c01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer current value register default value (0x00) <br /></td></tr>
<tr class="separator:a05f883ec74ea96fba44704b6d29f5c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe6a15ea4f3c051abe4920f6801f0a6"><td class="memItemLeft" align="right" valign="top"><a id="afbe6a15ea4f3c051abe4920f6801f0a6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#afbe6a15ea4f3c051abe4920f6801f0a6">REG_TIMER_INITIAL</a> = 0x1a</td></tr>
<tr class="memdesc:afbe6a15ea4f3c051abe4920f6801f0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer inital (reload) value register. <br /></td></tr>
<tr class="separator:afbe6a15ea4f3c051abe4920f6801f0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e4cef69c845b4b350c0da5cb0fe798"><td class="memItemLeft" align="right" valign="top"><a id="ad9e4cef69c845b4b350c0da5cb0fe798"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ad9e4cef69c845b4b350c0da5cb0fe798">REG_TIMER_INITIAL_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:ad9e4cef69c845b4b350c0da5cb0fe798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Countdown timer inital value register default value. <br /></td></tr>
<tr class="separator:ad9e4cef69c845b4b350c0da5cb0fe798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d55e19c6f09bffcd3e5ad5b74dbc7dd"><td class="memItemLeft" align="right" valign="top"><a id="a9d55e19c6f09bffcd3e5ad5b74dbc7dd"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a9d55e19c6f09bffcd3e5ad5b74dbc7dd">REG_WDT</a> = 0x1b</td></tr>
<tr class="memdesc:a9d55e19c6f09bffcd3e5ad5b74dbc7dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control register. <br /></td></tr>
<tr class="separator:a9d55e19c6f09bffcd3e5ad5b74dbc7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab25b5f5b2c98f477bd4be54ce8bdd4fb"><td class="memItemLeft" align="right" valign="top"><a id="ab25b5f5b2c98f477bd4be54ce8bdd4fb"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab25b5f5b2c98f477bd4be54ce8bdd4fb">REG_WDT_RESET</a> = 0x80</td></tr>
<tr class="memdesc:ab25b5f5b2c98f477bd4be54ce8bdd4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control, enable reset (1) or WIRQ (0) <br /></td></tr>
<tr class="separator:ab25b5f5b2c98f477bd4be54ce8bdd4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33da824ea172d174e342204333dc81a5"><td class="memItemLeft" align="right" valign="top"><a id="a33da824ea172d174e342204333dc81a5"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a33da824ea172d174e342204333dc81a5">REG_WDT_WRB_16_HZ</a> = 0x00</td></tr>
<tr class="memdesc:a33da824ea172d174e342204333dc81a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control, WRB watchdog clock = 16 Hz. <br /></td></tr>
<tr class="separator:a33da824ea172d174e342204333dc81a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0a157e322576da174116f8255b7991"><td class="memItemLeft" align="right" valign="top"><a id="a2f0a157e322576da174116f8255b7991"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2f0a157e322576da174116f8255b7991">REG_WDT_WRB_4_HZ</a> = 0x01</td></tr>
<tr class="memdesc:a2f0a157e322576da174116f8255b7991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control, WRB watchdog clock = 4 Hz. <br /></td></tr>
<tr class="separator:a2f0a157e322576da174116f8255b7991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0593fc4acce276b790ac1f10aa526d94"><td class="memItemLeft" align="right" valign="top"><a id="a0593fc4acce276b790ac1f10aa526d94"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a0593fc4acce276b790ac1f10aa526d94">REG_WDT_WRB_1_HZ</a> = 0x02</td></tr>
<tr class="memdesc:a0593fc4acce276b790ac1f10aa526d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control, WRB watchdog clock = 1 Hz. <br /></td></tr>
<tr class="separator:a0593fc4acce276b790ac1f10aa526d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285f3435d3a129eedfb222b561535956"><td class="memItemLeft" align="right" valign="top"><a id="a285f3435d3a129eedfb222b561535956"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a285f3435d3a129eedfb222b561535956">REG_WDT_WRB_1_4_HZ</a> = 0x03</td></tr>
<tr class="memdesc:a285f3435d3a129eedfb222b561535956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control, WRB watchdog clock = 1/4 Hz. <br /></td></tr>
<tr class="separator:a285f3435d3a129eedfb222b561535956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279d5363eb7d8d0ee489db07a8f62020"><td class="memItemLeft" align="right" valign="top"><a id="a279d5363eb7d8d0ee489db07a8f62020"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a279d5363eb7d8d0ee489db07a8f62020">REG_WDT_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:a279d5363eb7d8d0ee489db07a8f62020"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog timer control, default value. <br /></td></tr>
<tr class="separator:a279d5363eb7d8d0ee489db07a8f62020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021e1ff1885f69ecea5f2e0eabc32739"><td class="memItemLeft" align="right" valign="top"><a id="a021e1ff1885f69ecea5f2e0eabc32739"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a021e1ff1885f69ecea5f2e0eabc32739">REG_OSC_CTRL</a> = 0x1c</td></tr>
<tr class="memdesc:a021e1ff1885f69ecea5f2e0eabc32739"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control register. <br /></td></tr>
<tr class="separator:a021e1ff1885f69ecea5f2e0eabc32739"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f756f7d5d780250489820a913253b39"><td class="memItemLeft" align="right" valign="top"><a id="a3f756f7d5d780250489820a913253b39"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3f756f7d5d780250489820a913253b39">REG_OSC_CTRL_OSEL</a> = 0x80</td></tr>
<tr class="memdesc:a3f756f7d5d780250489820a913253b39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, clock select 32.768 kHz (0) or 128 Hz (1) <br /></td></tr>
<tr class="separator:a3f756f7d5d780250489820a913253b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d86b16cd1018daa4bbe93ddf4b0f250"><td class="memItemLeft" align="right" valign="top"><a id="a6d86b16cd1018daa4bbe93ddf4b0f250"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6d86b16cd1018daa4bbe93ddf4b0f250">REG_OSC_CTRL_ACAL</a> = 0x60</td></tr>
<tr class="memdesc:a6d86b16cd1018daa4bbe93ddf4b0f250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, auto-calibration. <br /></td></tr>
<tr class="separator:a6d86b16cd1018daa4bbe93ddf4b0f250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac72630f5e7fa639c4adee60ce0dbe0b6"><td class="memItemLeft" align="right" valign="top"><a id="ac72630f5e7fa639c4adee60ce0dbe0b6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac72630f5e7fa639c4adee60ce0dbe0b6">REG_OSC_CTRL_AOS</a> = 0x10</td></tr>
<tr class="memdesc:ac72630f5e7fa639c4adee60ce0dbe0b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, automatic switch to RC oscillator on battery. <br /></td></tr>
<tr class="separator:ac72630f5e7fa639c4adee60ce0dbe0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1827abfbebfa6f28659a42cb99a7be76"><td class="memItemLeft" align="right" valign="top"><a id="a1827abfbebfa6f28659a42cb99a7be76"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a1827abfbebfa6f28659a42cb99a7be76">REG_OSC_CTRL_FOS</a> = 0x08</td></tr>
<tr class="memdesc:a1827abfbebfa6f28659a42cb99a7be76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, automatic switch to RC oscillator on failure. <br /></td></tr>
<tr class="separator:a1827abfbebfa6f28659a42cb99a7be76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c219a5d4ec0573da57a3d0bc9e9287"><td class="memItemLeft" align="right" valign="top"><a id="a17c219a5d4ec0573da57a3d0bc9e9287"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a17c219a5d4ec0573da57a3d0bc9e9287">REG_OSC_CTRL_PWGT</a> = 0x04</td></tr>
<tr class="memdesc:a17c219a5d4ec0573da57a3d0bc9e9287"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, IO interface disable. <br /></td></tr>
<tr class="separator:a17c219a5d4ec0573da57a3d0bc9e9287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b6f2a8898a2a982a723cbf1737fb7e"><td class="memItemLeft" align="right" valign="top"><a id="a67b6f2a8898a2a982a723cbf1737fb7e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a67b6f2a8898a2a982a723cbf1737fb7e">REG_OSC_CTRL_OFIE</a> = 0x02</td></tr>
<tr class="memdesc:a67b6f2a8898a2a982a723cbf1737fb7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, oscillator fail interrupt enable. <br /></td></tr>
<tr class="separator:a67b6f2a8898a2a982a723cbf1737fb7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eb94af0c4188e25e5d4a4bea8f0bc9"><td class="memItemLeft" align="right" valign="top"><a id="a52eb94af0c4188e25e5d4a4bea8f0bc9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a52eb94af0c4188e25e5d4a4bea8f0bc9">REG_OSC_CTRL_ACIE</a> = 0x01</td></tr>
<tr class="memdesc:a52eb94af0c4188e25e5d4a4bea8f0bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, auto-calibration fail interrupt enable. <br /></td></tr>
<tr class="separator:a52eb94af0c4188e25e5d4a4bea8f0bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a460dd5ac3a034dbdc89fed81e4830896"><td class="memItemLeft" align="right" valign="top"><a id="a460dd5ac3a034dbdc89fed81e4830896"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a460dd5ac3a034dbdc89fed81e4830896">REG_OSC_CTRL_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:a460dd5ac3a034dbdc89fed81e4830896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator control, default value. <br /></td></tr>
<tr class="separator:a460dd5ac3a034dbdc89fed81e4830896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af13846eef802860032cb1b72085388e5"><td class="memItemLeft" align="right" valign="top"><a id="af13846eef802860032cb1b72085388e5"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#af13846eef802860032cb1b72085388e5">REG_OSC_STATUS</a> = 0x1d</td></tr>
<tr class="memdesc:af13846eef802860032cb1b72085388e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator status register. <br /></td></tr>
<tr class="separator:af13846eef802860032cb1b72085388e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad860cd19184e632c24b0f7e923eea327"><td class="memItemLeft" align="right" valign="top"><a id="ad860cd19184e632c24b0f7e923eea327"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ad860cd19184e632c24b0f7e923eea327">REG_OSC_STATUS_XTCAL</a> = 0x0c</td></tr>
<tr class="memdesc:ad860cd19184e632c24b0f7e923eea327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator status register, extended crystal calibration. <br /></td></tr>
<tr class="separator:ad860cd19184e632c24b0f7e923eea327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f2353b893e9ee09b91792f087bc8264"><td class="memItemLeft" align="right" valign="top"><a id="a8f2353b893e9ee09b91792f087bc8264"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8f2353b893e9ee09b91792f087bc8264">REG_OSC_STATUS_LKO2</a> = 0x04</td></tr>
<tr class="memdesc:a8f2353b893e9ee09b91792f087bc8264"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator status register, lock OUT2. <br /></td></tr>
<tr class="separator:a8f2353b893e9ee09b91792f087bc8264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a707264fde287ce1ab51de58248b363ad"><td class="memItemLeft" align="right" valign="top"><a id="a707264fde287ce1ab51de58248b363ad"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a707264fde287ce1ab51de58248b363ad">REG_OSC_STATUS_OMODE</a> = 0x01</td></tr>
<tr class="memdesc:a707264fde287ce1ab51de58248b363ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator status register, oscillator mode (read-only) <br /></td></tr>
<tr class="separator:a707264fde287ce1ab51de58248b363ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49c51a39bd84aabf8445031dd7eaed1"><td class="memItemLeft" align="right" valign="top"><a id="ad49c51a39bd84aabf8445031dd7eaed1"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ad49c51a39bd84aabf8445031dd7eaed1">REG_OSC_STATUS_OF</a> = 0x02</td></tr>
<tr class="memdesc:ad49c51a39bd84aabf8445031dd7eaed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator status register, oscillator failure. <br /></td></tr>
<tr class="separator:ad49c51a39bd84aabf8445031dd7eaed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2bebec75c4151f7b7208cdf24e37ae6"><td class="memItemLeft" align="right" valign="top"><a id="aa2bebec75c4151f7b7208cdf24e37ae6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa2bebec75c4151f7b7208cdf24e37ae6">REG_OSC_STATUS_ACF</a> = 0x01</td></tr>
<tr class="memdesc:aa2bebec75c4151f7b7208cdf24e37ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Oscillator status register, auto-calibration failure. <br /></td></tr>
<tr class="separator:aa2bebec75c4151f7b7208cdf24e37ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab587aebb3fa219babe3e8f0fa430c021"><td class="memItemLeft" align="right" valign="top"><a id="ab587aebb3fa219babe3e8f0fa430c021"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab587aebb3fa219babe3e8f0fa430c021">REG_CONFIG_KEY</a> = 0x1f</td></tr>
<tr class="memdesc:ab587aebb3fa219babe3e8f0fa430c021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register to set to modify certain other keys. <br /></td></tr>
<tr class="separator:ab587aebb3fa219babe3e8f0fa430c021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee090b3cec900a4c7c39f3c72f4509c3"><td class="memItemLeft" align="right" valign="top"><a id="aee090b3cec900a4c7c39f3c72f4509c3"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aee090b3cec900a4c7c39f3c72f4509c3">REG_CONFIG_KEY_OSC_CTRL</a> = 0xa1</td></tr>
<tr class="memdesc:aee090b3cec900a4c7c39f3c72f4509c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration key, enable setting REG_OSC_CTRL. <br /></td></tr>
<tr class="separator:aee090b3cec900a4c7c39f3c72f4509c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d6b5507b8ad35da0bd2c13ad40f11d"><td class="memItemLeft" align="right" valign="top"><a id="a71d6b5507b8ad35da0bd2c13ad40f11d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a71d6b5507b8ad35da0bd2c13ad40f11d">REG_CONFIG_KEY_SW_RESET</a> = 0x3c</td></tr>
<tr class="memdesc:a71d6b5507b8ad35da0bd2c13ad40f11d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration key, software reset. <br /></td></tr>
<tr class="separator:a71d6b5507b8ad35da0bd2c13ad40f11d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a518e95387f75487c5c3bac44f2e2b655"><td class="memItemLeft" align="right" valign="top"><a id="a518e95387f75487c5c3bac44f2e2b655"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a518e95387f75487c5c3bac44f2e2b655">REG_CONFIG_KEY_OTHER</a> = 0x9d</td></tr>
<tr class="memdesc:a518e95387f75487c5c3bac44f2e2b655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configuration key, REG_TRICKLE, REG_BREF_CTRL, REG_AFCTRL, REG_BATMODE_IO, REG_OCTRL. <br /></td></tr>
<tr class="separator:a518e95387f75487c5c3bac44f2e2b655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f84ccad3df1891742fdfe237fc03ea"><td class="memItemLeft" align="right" valign="top"><a id="a46f84ccad3df1891742fdfe237fc03ea"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a46f84ccad3df1891742fdfe237fc03ea">REG_TRICKLE</a> = 0x20</td></tr>
<tr class="memdesc:a46f84ccad3df1891742fdfe237fc03ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register. <br /></td></tr>
<tr class="separator:a46f84ccad3df1891742fdfe237fc03ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f31a34bb3225812ffdb16475a12d73"><td class="memItemLeft" align="right" valign="top"><a id="a48f31a34bb3225812ffdb16475a12d73"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a48f31a34bb3225812ffdb16475a12d73">REG_TRICKLE_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:a48f31a34bb3225812ffdb16475a12d73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, default value. <br /></td></tr>
<tr class="separator:a48f31a34bb3225812ffdb16475a12d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad426b75c64de40ef12a544b8c7d07c0"><td class="memItemLeft" align="right" valign="top"><a id="aad426b75c64de40ef12a544b8c7d07c0"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aad426b75c64de40ef12a544b8c7d07c0">REG_TRICKLE_TCS_MASK</a> = 0xf0</td></tr>
<tr class="memdesc:aad426b75c64de40ef12a544b8c7d07c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, enable mask. <br /></td></tr>
<tr class="separator:aad426b75c64de40ef12a544b8c7d07c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e1a2e7f2ea545768c70584faffd7e3"><td class="memItemLeft" align="right" valign="top"><a id="a85e1a2e7f2ea545768c70584faffd7e3"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a85e1a2e7f2ea545768c70584faffd7e3">REG_TRICKLE_TCS_ENABLE</a> = 0xa0</td></tr>
<tr class="memdesc:a85e1a2e7f2ea545768c70584faffd7e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, enable value (0b10100000) <br /></td></tr>
<tr class="separator:a85e1a2e7f2ea545768c70584faffd7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbfad204613499cd0d77d1a813006a91"><td class="memItemLeft" align="right" valign="top"><a id="adbfad204613499cd0d77d1a813006a91"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#adbfad204613499cd0d77d1a813006a91">REG_TRICKLE_DIODE_MASK</a> = 0x0c</td></tr>
<tr class="memdesc:adbfad204613499cd0d77d1a813006a91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, diode mask. <br /></td></tr>
<tr class="separator:adbfad204613499cd0d77d1a813006a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a622ab82d2610162d99173748e22cd607"><td class="memItemLeft" align="right" valign="top"><a id="a622ab82d2610162d99173748e22cd607"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a622ab82d2610162d99173748e22cd607">REG_TRICKLE_DIODE_0_6</a> = 0x08</td></tr>
<tr class="memdesc:a622ab82d2610162d99173748e22cd607"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, diode 0.6V drop. <br /></td></tr>
<tr class="separator:a622ab82d2610162d99173748e22cd607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8fc55a7163497033470603266d49b0f"><td class="memItemLeft" align="right" valign="top"><a id="ab8fc55a7163497033470603266d49b0f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab8fc55a7163497033470603266d49b0f">REG_TRICKLE_DIODE_0_3</a> = 0x04</td></tr>
<tr class="memdesc:ab8fc55a7163497033470603266d49b0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, diode 0.3V drop. <br /></td></tr>
<tr class="separator:ab8fc55a7163497033470603266d49b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5afff4b02eaa8a5d9244ba4b8386254c"><td class="memItemLeft" align="right" valign="top"><a id="a5afff4b02eaa8a5d9244ba4b8386254c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5afff4b02eaa8a5d9244ba4b8386254c">REG_TRICKLE_ROUT_MASK</a> = 0x03</td></tr>
<tr class="memdesc:a5afff4b02eaa8a5d9244ba4b8386254c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, rout mask. <br /></td></tr>
<tr class="separator:a5afff4b02eaa8a5d9244ba4b8386254c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4384f0247b4fce9a878764920473ca7"><td class="memItemLeft" align="right" valign="top"><a id="ae4384f0247b4fce9a878764920473ca7"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae4384f0247b4fce9a878764920473ca7">REG_TRICKLE_ROUT_11K</a> = 0x03</td></tr>
<tr class="memdesc:ae4384f0247b4fce9a878764920473ca7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, rout 11K. <br /></td></tr>
<tr class="separator:ae4384f0247b4fce9a878764920473ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f31552d3573659f9444d96bccfc04e"><td class="memItemLeft" align="right" valign="top"><a id="a58f31552d3573659f9444d96bccfc04e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a58f31552d3573659f9444d96bccfc04e">REG_TRICKLE_ROUT_6K</a> = 0x02</td></tr>
<tr class="memdesc:a58f31552d3573659f9444d96bccfc04e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, rout 6K. <br /></td></tr>
<tr class="separator:a58f31552d3573659f9444d96bccfc04e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a3ea3db413eecf0b7c4a20e7663bc6"><td class="memItemLeft" align="right" valign="top"><a id="ac5a3ea3db413eecf0b7c4a20e7663bc6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ac5a3ea3db413eecf0b7c4a20e7663bc6">REG_TRICKLE_ROUT_3K</a> = 0x01</td></tr>
<tr class="memdesc:ac5a3ea3db413eecf0b7c4a20e7663bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, rout 3K. <br /></td></tr>
<tr class="separator:ac5a3ea3db413eecf0b7c4a20e7663bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0044c75c6f93bb6c9cbd5d2209dc3c0"><td class="memItemLeft" align="right" valign="top"><a id="af0044c75c6f93bb6c9cbd5d2209dc3c0"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#af0044c75c6f93bb6c9cbd5d2209dc3c0">REG_TRICKLE_ROUT_DISABLE</a> = 0x00</td></tr>
<tr class="memdesc:af0044c75c6f93bb6c9cbd5d2209dc3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trickle charger control register, rout disable. <br /></td></tr>
<tr class="separator:af0044c75c6f93bb6c9cbd5d2209dc3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f29ce43c78fb8023094e5a628943484"><td class="memItemLeft" align="right" valign="top"><a id="a2f29ce43c78fb8023094e5a628943484"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2f29ce43c78fb8023094e5a628943484">REG_BREF_CTRL</a> = 0x21</td></tr>
<tr class="memdesc:a2f29ce43c78fb8023094e5a628943484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup control system reference voltages. <br /></td></tr>
<tr class="separator:a2f29ce43c78fb8023094e5a628943484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abf9ebb172bdec2fb1a559dfd914066"><td class="memItemLeft" align="right" valign="top"><a id="a8abf9ebb172bdec2fb1a559dfd914066"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8abf9ebb172bdec2fb1a559dfd914066">REG_BREF_CTRL_DEFAULT</a> = 0xf0</td></tr>
<tr class="memdesc:a8abf9ebb172bdec2fb1a559dfd914066"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup control system default 0b11110000. <br /></td></tr>
<tr class="separator:a8abf9ebb172bdec2fb1a559dfd914066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e854036e10237014af613053601d087"><td class="memItemLeft" align="right" valign="top"><a id="a5e854036e10237014af613053601d087"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5e854036e10237014af613053601d087">REG_BREF_CTRL_25_30</a> = 0x70</td></tr>
<tr class="memdesc:a5e854036e10237014af613053601d087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup control falling 2.5V rising 3.0V. <br /></td></tr>
<tr class="separator:a5e854036e10237014af613053601d087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e612ca01a1c5816832826b9946a4dec"><td class="memItemLeft" align="right" valign="top"><a id="a0e612ca01a1c5816832826b9946a4dec"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a0e612ca01a1c5816832826b9946a4dec">REG_BREF_CTRL_21_25</a> = 0xb0</td></tr>
<tr class="memdesc:a0e612ca01a1c5816832826b9946a4dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup control falling 2.1V rising 2.5V. <br /></td></tr>
<tr class="separator:a0e612ca01a1c5816832826b9946a4dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658b5fe343527c54a6cf40887d0fa48a"><td class="memItemLeft" align="right" valign="top"><a id="a658b5fe343527c54a6cf40887d0fa48a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a658b5fe343527c54a6cf40887d0fa48a">REG_BREF_CTRL_18_22</a> = 0xd0</td></tr>
<tr class="memdesc:a658b5fe343527c54a6cf40887d0fa48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup control falling 1.8V rising 2.2V. <br /></td></tr>
<tr class="separator:a658b5fe343527c54a6cf40887d0fa48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd35a183e5e2f8d5286b730886356d4f"><td class="memItemLeft" align="right" valign="top"><a id="abd35a183e5e2f8d5286b730886356d4f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#abd35a183e5e2f8d5286b730886356d4f">REG_BREF_CTRL_14_16</a> = 0xf0</td></tr>
<tr class="memdesc:abd35a183e5e2f8d5286b730886356d4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wakeup control falling 1.4V rising 1.6V, default value. <br /></td></tr>
<tr class="separator:abd35a183e5e2f8d5286b730886356d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86e5f8cec6545d6c506be7f05fae7f83"><td class="memItemLeft" align="right" valign="top"><a id="a86e5f8cec6545d6c506be7f05fae7f83"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a86e5f8cec6545d6c506be7f05fae7f83">REG_AFCTRL</a> = 0x26</td></tr>
<tr class="memdesc:a86e5f8cec6545d6c506be7f05fae7f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-calibration filter capacitor enable register. <br /></td></tr>
<tr class="separator:a86e5f8cec6545d6c506be7f05fae7f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898a3cad08b7d121f8aec25ac18f9328"><td class="memItemLeft" align="right" valign="top"><a id="a898a3cad08b7d121f8aec25ac18f9328"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a898a3cad08b7d121f8aec25ac18f9328">REG_AFCTRL_ENABLE</a> = 0xa0</td></tr>
<tr class="memdesc:a898a3cad08b7d121f8aec25ac18f9328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-calibration filter capacitor enable. <br /></td></tr>
<tr class="separator:a898a3cad08b7d121f8aec25ac18f9328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de91dc8626f632984ff7addfe26634"><td class="memItemLeft" align="right" valign="top"><a id="a89de91dc8626f632984ff7addfe26634"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a89de91dc8626f632984ff7addfe26634">REG_AFCTRL_DISABLE</a> = 0x00</td></tr>
<tr class="memdesc:a89de91dc8626f632984ff7addfe26634"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-calibration filter capacitor disable. <br /></td></tr>
<tr class="separator:a89de91dc8626f632984ff7addfe26634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee220bf29a125957a27d15ede622952d"><td class="memItemLeft" align="right" valign="top"><a id="aee220bf29a125957a27d15ede622952d"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aee220bf29a125957a27d15ede622952d">REG_AFCTRL_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:aee220bf29a125957a27d15ede622952d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Auto-calibration filter, default. <br /></td></tr>
<tr class="separator:aee220bf29a125957a27d15ede622952d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a412c63573b84dceb63405daece15bfb4"><td class="memItemLeft" align="right" valign="top"><a id="a412c63573b84dceb63405daece15bfb4"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a412c63573b84dceb63405daece15bfb4">REG_BATMODE_IO</a> = 0x27</td></tr>
<tr class="memdesc:a412c63573b84dceb63405daece15bfb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brownout control for IO interface. <br /></td></tr>
<tr class="separator:a412c63573b84dceb63405daece15bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a668f6ac5b7c378d0dbb6b38cb62d1021"><td class="memItemLeft" align="right" valign="top"><a id="a668f6ac5b7c378d0dbb6b38cb62d1021"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a668f6ac5b7c378d0dbb6b38cb62d1021">REG_BATMODE_IO_DEFAULT</a> = 0x80</td></tr>
<tr class="memdesc:a668f6ac5b7c378d0dbb6b38cb62d1021"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brownout control for IO interface, default value. <br /></td></tr>
<tr class="separator:a668f6ac5b7c378d0dbb6b38cb62d1021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05465c7cf48df24fef3a0894850da190"><td class="memItemLeft" align="right" valign="top"><a id="a05465c7cf48df24fef3a0894850da190"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a05465c7cf48df24fef3a0894850da190">REG_BATMODE_IO_IOBM</a> = 0x80</td></tr>
<tr class="memdesc:a05465c7cf48df24fef3a0894850da190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Brownout control for IO interface, enable IO when on VBAT. <br /></td></tr>
<tr class="separator:a05465c7cf48df24fef3a0894850da190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1a89938d70abaddab83813e1f14f60"><td class="memItemLeft" align="right" valign="top"><a id="a8f1a89938d70abaddab83813e1f14f60"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8f1a89938d70abaddab83813e1f14f60">REG_ID0</a> = 0x28</td></tr>
<tr class="memdesc:a8f1a89938d70abaddab83813e1f14f60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part number, upper (read-only) <br /></td></tr>
<tr class="separator:a8f1a89938d70abaddab83813e1f14f60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6860924bfc3eb7378ef875330529bbf"><td class="memItemLeft" align="right" valign="top"><a id="ae6860924bfc3eb7378ef875330529bbf"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae6860924bfc3eb7378ef875330529bbf">REG_ID0_AB08XX</a> = 0x18</td></tr>
<tr class="memdesc:ae6860924bfc3eb7378ef875330529bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part number, upper, AB08xx. <br /></td></tr>
<tr class="separator:ae6860924bfc3eb7378ef875330529bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74a451b3412b33b073bfd1051ba30a3"><td class="memItemLeft" align="right" valign="top"><a id="ad74a451b3412b33b073bfd1051ba30a3"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ad74a451b3412b33b073bfd1051ba30a3">REG_ID0_AB18XX</a> = 0x18</td></tr>
<tr class="memdesc:ad74a451b3412b33b073bfd1051ba30a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part number, upper, AB18xx. <br /></td></tr>
<tr class="separator:ad74a451b3412b33b073bfd1051ba30a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9c371b4f43e4e06079aad6d187a0bb"><td class="memItemLeft" align="right" valign="top"><a id="aba9c371b4f43e4e06079aad6d187a0bb"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aba9c371b4f43e4e06079aad6d187a0bb">REG_ID1</a> = 0x29</td></tr>
<tr class="memdesc:aba9c371b4f43e4e06079aad6d187a0bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part number, lower (read-only) <br /></td></tr>
<tr class="separator:aba9c371b4f43e4e06079aad6d187a0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e311164704782a012a7cea56eed7a"><td class="memItemLeft" align="right" valign="top"><a id="a4a7e311164704782a012a7cea56eed7a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a4a7e311164704782a012a7cea56eed7a">REG_ID1_ABXX05</a> = 0x05</td></tr>
<tr class="memdesc:a4a7e311164704782a012a7cea56eed7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part number, lower, <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> or AB0805 (I2C) <br /></td></tr>
<tr class="separator:a4a7e311164704782a012a7cea56eed7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501335d553c745ee49f3b2d95c476be8"><td class="memItemLeft" align="right" valign="top"><a id="a501335d553c745ee49f3b2d95c476be8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a501335d553c745ee49f3b2d95c476be8">REG_ID1_ABXX15</a> = 0x05</td></tr>
<tr class="memdesc:a501335d553c745ee49f3b2d95c476be8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part number, lower, AB1815 or AB0815 (SPI) <br /></td></tr>
<tr class="separator:a501335d553c745ee49f3b2d95c476be8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79891d8b712fdcc3359b97735fcb573c"><td class="memItemLeft" align="right" valign="top"><a id="a79891d8b712fdcc3359b97735fcb573c"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a79891d8b712fdcc3359b97735fcb573c">REG_ID2</a> = 0x2a</td></tr>
<tr class="memdesc:a79891d8b712fdcc3359b97735fcb573c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Part revision (read-only) <br /></td></tr>
<tr class="separator:a79891d8b712fdcc3359b97735fcb573c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf73042d81dccfae1f0f9c5084456dcd"><td class="memItemLeft" align="right" valign="top"><a id="abf73042d81dccfae1f0f9c5084456dcd"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#abf73042d81dccfae1f0f9c5084456dcd">REG_ID3</a> = 0x2b</td></tr>
<tr class="memdesc:abf73042d81dccfae1f0f9c5084456dcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lot number, lower (read-only) <br /></td></tr>
<tr class="separator:abf73042d81dccfae1f0f9c5084456dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa978506845b7cb32497b0f7e91c1e22f"><td class="memItemLeft" align="right" valign="top"><a id="aa978506845b7cb32497b0f7e91c1e22f"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa978506845b7cb32497b0f7e91c1e22f">REG_ID4</a> = 0x2c</td></tr>
<tr class="memdesc:aa978506845b7cb32497b0f7e91c1e22f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manufacturing unique ID upper (read-only) <br /></td></tr>
<tr class="separator:aa978506845b7cb32497b0f7e91c1e22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311b935a0912871c74a99a80a8c3e170"><td class="memItemLeft" align="right" valign="top"><a id="a311b935a0912871c74a99a80a8c3e170"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a311b935a0912871c74a99a80a8c3e170">REG_ID5</a> = 0x2d</td></tr>
<tr class="memdesc:a311b935a0912871c74a99a80a8c3e170"><td class="mdescLeft">&#160;</td><td class="mdescRight">Manufacturing unique ID lower (read-only) <br /></td></tr>
<tr class="separator:a311b935a0912871c74a99a80a8c3e170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ffa3cd2cacec214a98275d97b4bb3a9"><td class="memItemLeft" align="right" valign="top"><a id="a5ffa3cd2cacec214a98275d97b4bb3a9"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5ffa3cd2cacec214a98275d97b4bb3a9">REG_ID6</a> = 0x2e</td></tr>
<tr class="memdesc:a5ffa3cd2cacec214a98275d97b4bb3a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lot and wafer information (read-only) <br /></td></tr>
<tr class="separator:a5ffa3cd2cacec214a98275d97b4bb3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c54ebeca5e5beee9c597b77095e3db1"><td class="memItemLeft" align="right" valign="top"><a id="a5c54ebeca5e5beee9c597b77095e3db1"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5c54ebeca5e5beee9c597b77095e3db1">REG_ASTAT</a> = 0x2f</td></tr>
<tr class="memdesc:a5c54ebeca5e5beee9c597b77095e3db1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog status register (read-only) <br /></td></tr>
<tr class="separator:a5c54ebeca5e5beee9c597b77095e3db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2589054a4858f1598be65ec0a316d990"><td class="memItemLeft" align="right" valign="top"><a id="a2589054a4858f1598be65ec0a316d990"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a2589054a4858f1598be65ec0a316d990">REG_ASTAT_BBOD</a> = 0x80</td></tr>
<tr class="memdesc:a2589054a4858f1598be65ec0a316d990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog status register. VBAT is above BREF (read-only) <br /></td></tr>
<tr class="separator:a2589054a4858f1598be65ec0a316d990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60c8e8d4de83500fdcd49c5ef5604308"><td class="memItemLeft" align="right" valign="top"><a id="a60c8e8d4de83500fdcd49c5ef5604308"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a60c8e8d4de83500fdcd49c5ef5604308">REG_ASTAT_BMIN</a> = 0x40</td></tr>
<tr class="memdesc:a60c8e8d4de83500fdcd49c5ef5604308"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog status register. VBAT is above minimum operating voltage 1.2V (read-only) <br /></td></tr>
<tr class="separator:a60c8e8d4de83500fdcd49c5ef5604308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a9ee56017821a3f4be7f891d2336686"><td class="memItemLeft" align="right" valign="top"><a id="a9a9ee56017821a3f4be7f891d2336686"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a9a9ee56017821a3f4be7f891d2336686">REG_ASTAT_VINIT</a> = 0x02</td></tr>
<tr class="memdesc:a9a9ee56017821a3f4be7f891d2336686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog status register. VCC is about minimum 1.6V (read-only) <br /></td></tr>
<tr class="separator:a9a9ee56017821a3f4be7f891d2336686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a690b47d033eb1bc52dd5e4fda47e4dee"><td class="memItemLeft" align="right" valign="top"><a id="a690b47d033eb1bc52dd5e4fda47e4dee"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a690b47d033eb1bc52dd5e4fda47e4dee">REG_OCTRL</a> = 0x30</td></tr>
<tr class="memdesc:a690b47d033eb1bc52dd5e4fda47e4dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register at power-down. <br /></td></tr>
<tr class="separator:a690b47d033eb1bc52dd5e4fda47e4dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24f39de7b55a04a538d042e310438a6"><td class="memItemLeft" align="right" valign="top"><a id="ab24f39de7b55a04a538d042e310438a6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ab24f39de7b55a04a538d042e310438a6">REG_OCTRL_WDBM</a> = 0x80</td></tr>
<tr class="memdesc:ab24f39de7b55a04a538d042e310438a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, WDI enabled when powered from VBAT. <br /></td></tr>
<tr class="separator:ab24f39de7b55a04a538d042e310438a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c2ce6b6e906105a5822d84673266fa8"><td class="memItemLeft" align="right" valign="top"><a id="a4c2ce6b6e906105a5822d84673266fa8"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a4c2ce6b6e906105a5822d84673266fa8">REG_OCTRL_EXBM</a> = 0x40</td></tr>
<tr class="memdesc:a4c2ce6b6e906105a5822d84673266fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, EXTI enabled when powered from VBAT. <br /></td></tr>
<tr class="separator:a4c2ce6b6e906105a5822d84673266fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e88883caa877a1fa8207884f1e6a0e6"><td class="memItemLeft" align="right" valign="top"><a id="a6e88883caa877a1fa8207884f1e6a0e6"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6e88883caa877a1fa8207884f1e6a0e6">REG_OCTRL_WDDS</a> = 0x20</td></tr>
<tr class="memdesc:a6e88883caa877a1fa8207884f1e6a0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, WDI disabled in sleep. <br /></td></tr>
<tr class="separator:a6e88883caa877a1fa8207884f1e6a0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc397694bee74c1ac736495a3ead0cee"><td class="memItemLeft" align="right" valign="top"><a id="adc397694bee74c1ac736495a3ead0cee"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#adc397694bee74c1ac736495a3ead0cee">REG_OCTRL_EXDS</a> = 0x10</td></tr>
<tr class="memdesc:adc397694bee74c1ac736495a3ead0cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, EXTI disabled in sleep. <br /></td></tr>
<tr class="separator:adc397694bee74c1ac736495a3ead0cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de26e21dfac76588b04a7f965ea4d6a"><td class="memItemLeft" align="right" valign="top"><a id="a5de26e21dfac76588b04a7f965ea4d6a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5de26e21dfac76588b04a7f965ea4d6a">REG_OCTRL_RSEN</a> = 0x08</td></tr>
<tr class="memdesc:a5de26e21dfac76588b04a7f965ea4d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, nRST output enabled in sleep. <br /></td></tr>
<tr class="separator:a5de26e21dfac76588b04a7f965ea4d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3618a5761bf6739638299abbec3704d7"><td class="memItemLeft" align="right" valign="top"><a id="a3618a5761bf6739638299abbec3704d7"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3618a5761bf6739638299abbec3704d7">REG_OCTRL_O4EN</a> = 0x04</td></tr>
<tr class="memdesc:a3618a5761bf6739638299abbec3704d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, CLKOUT/nIRQ3 enabled in sleep. <br /></td></tr>
<tr class="separator:a3618a5761bf6739638299abbec3704d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2755485a5778a12d81b3307ef06f3bd"><td class="memItemLeft" align="right" valign="top"><a id="ae2755485a5778a12d81b3307ef06f3bd"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae2755485a5778a12d81b3307ef06f3bd">REG_OCTRL_O3EN</a> = 0x02</td></tr>
<tr class="memdesc:ae2755485a5778a12d81b3307ef06f3bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, nTIRQ enabled in sleep. <br /></td></tr>
<tr class="separator:ae2755485a5778a12d81b3307ef06f3bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044720aa6691bcf670f89077125c23e7"><td class="memItemLeft" align="right" valign="top"><a id="a044720aa6691bcf670f89077125c23e7"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a044720aa6691bcf670f89077125c23e7">REG_OCTRL_O1EN</a> = 0x01</td></tr>
<tr class="memdesc:a044720aa6691bcf670f89077125c23e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, FOUT/nIRQ enabled in sleep. <br /></td></tr>
<tr class="separator:a044720aa6691bcf670f89077125c23e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c33cb8283bcf41b99e37988ba38ce33"><td class="memItemLeft" align="right" valign="top"><a id="a9c33cb8283bcf41b99e37988ba38ce33"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a9c33cb8283bcf41b99e37988ba38ce33">REG_OCTRL_DEFAULT</a> = 0x00</td></tr>
<tr class="memdesc:a9c33cb8283bcf41b99e37988ba38ce33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Output control register, default. <br /></td></tr>
<tr class="separator:a9c33cb8283bcf41b99e37988ba38ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3288ed8c2076d7607ee90804ace3d994"><td class="memItemLeft" align="right" valign="top"><a id="a3288ed8c2076d7607ee90804ace3d994"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3288ed8c2076d7607ee90804ace3d994">REG_EXT_ADDR</a> = 0x3f</td></tr>
<tr class="memdesc:a3288ed8c2076d7607ee90804ace3d994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address. <br /></td></tr>
<tr class="separator:a3288ed8c2076d7607ee90804ace3d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9cef5ea85c0d7dc3811753d6ec11895"><td class="memItemLeft" align="right" valign="top"><a id="ae9cef5ea85c0d7dc3811753d6ec11895"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#ae9cef5ea85c0d7dc3811753d6ec11895">REG_EXT_ADDR_O4MB</a> = 0x80</td></tr>
<tr class="memdesc:ae9cef5ea85c0d7dc3811753d6ec11895"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address, CLKOUT/nIRQ3 enabled when powered from VBAT. <br /></td></tr>
<tr class="separator:ae9cef5ea85c0d7dc3811753d6ec11895"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9400585c8d3a1ab703856041ac8017fe"><td class="memItemLeft" align="right" valign="top"><a id="a9400585c8d3a1ab703856041ac8017fe"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a9400585c8d3a1ab703856041ac8017fe">REG_EXT_ADDR_BPOL</a> = 0x40</td></tr>
<tr class="memdesc:a9400585c8d3a1ab703856041ac8017fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address, BL polarity. <br /></td></tr>
<tr class="separator:a9400585c8d3a1ab703856041ac8017fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf2acc1351acffa0febc367e5ab7c57"><td class="memItemLeft" align="right" valign="top"><a id="adbf2acc1351acffa0febc367e5ab7c57"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#adbf2acc1351acffa0febc367e5ab7c57">REG_EXT_ADDR_WDIN</a> = 0x20</td></tr>
<tr class="memdesc:adbf2acc1351acffa0febc367e5ab7c57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address, level of WDI pin (read-only) <br /></td></tr>
<tr class="separator:adbf2acc1351acffa0febc367e5ab7c57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ea06ef013df2fee67d74894403a0e"><td class="memItemLeft" align="right" valign="top"><a id="aca4ea06ef013df2fee67d74894403a0e"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aca4ea06ef013df2fee67d74894403a0e">REG_EXT_ADDR_EXIN</a> = 0x10</td></tr>
<tr class="memdesc:aca4ea06ef013df2fee67d74894403a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address, level of EXTI pin (read-only) <br /></td></tr>
<tr class="separator:aca4ea06ef013df2fee67d74894403a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae8c0df015cda696a5be552a2da0b23"><td class="memItemLeft" align="right" valign="top"><a id="a8ae8c0df015cda696a5be552a2da0b23"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a8ae8c0df015cda696a5be552a2da0b23">REG_EXT_ADDR_XADA</a> = 0x04</td></tr>
<tr class="memdesc:a8ae8c0df015cda696a5be552a2da0b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address, Upper bit of alternate RAM address. <br /></td></tr>
<tr class="separator:a8ae8c0df015cda696a5be552a2da0b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa516b82ef4a355635e20fe4750a14d6a"><td class="memItemLeft" align="right" valign="top"><a id="aa516b82ef4a355635e20fe4750a14d6a"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aa516b82ef4a355635e20fe4750a14d6a">REG_EXT_ADDR_XADS</a> = 0x03</td></tr>
<tr class="memdesc:aa516b82ef4a355635e20fe4750a14d6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extension RAM address, Upper 2 bits of standard RAM address. <br /></td></tr>
<tr class="separator:aa516b82ef4a355635e20fe4750a14d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea4f8d92256af72acecef0af86ea18ec"><td class="memItemLeft" align="right" valign="top"><a id="aea4f8d92256af72acecef0af86ea18ec"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aea4f8d92256af72acecef0af86ea18ec">REG_RAM</a> = 0x40</td></tr>
<tr class="memdesc:aea4f8d92256af72acecef0af86ea18ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard RAM. <br /></td></tr>
<tr class="separator:aea4f8d92256af72acecef0af86ea18ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0230cc29a3b97a04a7ad9d65c92deaac"><td class="memItemLeft" align="right" valign="top"><a id="a0230cc29a3b97a04a7ad9d65c92deaac"></a>
static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a0230cc29a3b97a04a7ad9d65c92deaac">REG_ALT_RAM</a> = 0x80</td></tr>
<tr class="memdesc:a0230cc29a3b97a04a7ad9d65c92deaac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate RAM address. <br /></td></tr>
<tr class="separator:a0230cc29a3b97a04a7ad9d65c92deaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a537c9642ad784fbd52423c3d0e074ab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a537c9642ad784fbd52423c3d0e074ab1">systemEvent</a> (system_event_t event, int param)</td></tr>
<tr class="memdesc:a537c9642ad784fbd52423c3d0e074ab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Internal function used to handle system events.  <a href="class_a_b1805.html#a537c9642ad784fbd52423c3d0e074ab1">More...</a><br /></td></tr>
<tr class="separator:a537c9642ad784fbd52423c3d0e074ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a6b079ff9593ced5da34f73111e72264e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6b079ff9593ced5da34f73111e72264e">systemEventStatic</a> (system_event_t event, int param)</td></tr>
<tr class="memdesc:a6b079ff9593ced5da34f73111e72264e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Static function passed to System.on.  <a href="class_a_b1805.html#a6b079ff9593ced5da34f73111e72264e">More...</a><br /></td></tr>
<tr class="separator:a6b079ff9593ced5da34f73111e72264e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a1144ea899a90e5b3f4f54ee819832656"><td class="memItemLeft" align="right" valign="top"><a id="a1144ea899a90e5b3f4f54ee819832656"></a>
TwoWire &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a1144ea899a90e5b3f4f54ee819832656">wire</a> = Wire</td></tr>
<tr class="memdesc:a1144ea899a90e5b3f4f54ee819832656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which I2C (TwoWire) interface to use. Usually Wire, is Wire1 on Tracker SoM. <br /></td></tr>
<tr class="separator:a1144ea899a90e5b3f4f54ee819832656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98648dc7b965fed0a114061301ff92c3"><td class="memItemLeft" align="right" valign="top"><a id="a98648dc7b965fed0a114061301ff92c3"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a98648dc7b965fed0a114061301ff92c3">i2cAddr</a> = 0x69</td></tr>
<tr class="memdesc:a98648dc7b965fed0a114061301ff92c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">I2C address, always 0x69 as that is the address hardwired in the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>. <br /></td></tr>
<tr class="separator:a98648dc7b965fed0a114061301ff92c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce37ba1f55c8661c4fafd41632369b6"><td class="memItemLeft" align="right" valign="top">pin_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a5ce37ba1f55c8661c4fafd41632369b6">foutPin</a> = PIN_INVALID</td></tr>
<tr class="memdesc:a5ce37ba1f55c8661c4fafd41632369b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Which GPIO is connected to FOUT/nIRQ.  <a href="class_a_b1805.html#a5ce37ba1f55c8661c4fafd41632369b6">More...</a><br /></td></tr>
<tr class="separator:a5ce37ba1f55c8661c4fafd41632369b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6592c54ae4a8eba3b23651b7d2151546"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a6592c54ae4a8eba3b23651b7d2151546">watchdogSecs</a> = 0</td></tr>
<tr class="memdesc:a6592c54ae4a8eba3b23651b7d2151546"><td class="mdescLeft">&#160;</td><td class="mdescRight">Watchdog period in seconds (1 &lt;= watchdogSecs &lt;= 124) or 0 for disabled.  <a href="class_a_b1805.html#a6592c54ae4a8eba3b23651b7d2151546">More...</a><br /></td></tr>
<tr class="separator:a6592c54ae4a8eba3b23651b7d2151546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3953da0394dc3912a79077ce751c9f5f"><td class="memItemLeft" align="right" valign="top"><a id="a3953da0394dc3912a79077ce751c9f5f"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a3953da0394dc3912a79077ce751c9f5f">lastWatchdogMillis</a> = 0</td></tr>
<tr class="memdesc:a3953da0394dc3912a79077ce751c9f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The last millis() value where we called setWDT(-1) <br /></td></tr>
<tr class="separator:a3953da0394dc3912a79077ce751c9f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea3ae0efc55a99dc19fe27f585f58ad1"><td class="memItemLeft" align="right" valign="top"><a id="aea3ae0efc55a99dc19fe27f585f58ad1"></a>
unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#aea3ae0efc55a99dc19fe27f585f58ad1">watchdogUpdatePeriod</a> = 0</td></tr>
<tr class="memdesc:aea3ae0efc55a99dc19fe27f585f58ad1"><td class="mdescLeft">&#160;</td><td class="mdescRight">How often to call updateWDT(-1) in milliseconds. <br /></td></tr>
<tr class="separator:aea3ae0efc55a99dc19fe27f585f58ad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65393e3d43980d222b7942cec25f57b8"><td class="memItemLeft" align="right" valign="top"><a id="a65393e3d43980d222b7942cec25f57b8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a65393e3d43980d222b7942cec25f57b8">timeSet</a> = false</td></tr>
<tr class="memdesc:a65393e3d43980d222b7942cec25f57b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if we've set the RTC from the cloud time. <br /></td></tr>
<tr class="separator:a65393e3d43980d222b7942cec25f57b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d18b00914896a7627753dc6a3aa41e"><td class="memItemLeft" align="right" valign="top"><a id="a28d18b00914896a7627753dc6a3aa41e"></a>
<a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5">WakeReason</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a28d18b00914896a7627753dc6a3aa41e">wakeReason</a> = <a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5a696b031073e74bf2cb98e5ef201d4aa3">WakeReason::UNKNOWN</a></td></tr>
<tr class="memdesc:a28d18b00914896a7627753dc6a3aa41e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The reason for wake. Set during <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">setup()</a> <br /></td></tr>
<tr class="separator:a28d18b00914896a7627753dc6a3aa41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a93d2b1f320a49fe156b0524b37e7a134"><td class="memItemLeft" align="right" valign="top"><a id="a93d2b1f320a49fe156b0524b37e7a134"></a>
static <a class="el" href="class_a_b1805.html">AB1805</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_a_b1805.html#a93d2b1f320a49fe156b0524b37e7a134">instance</a> = 0</td></tr>
<tr class="memdesc:a93d2b1f320a49fe156b0524b37e7a134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton for <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>. Set in constructor. <br /></td></tr>
<tr class="separator:a93d2b1f320a49fe156b0524b37e7a134"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Class for using the AB1805/AM1805 RTC/watchdog chip. </p>
<p>You typically allocate one of these objects as a global variable as a singleton. You can only have one of these objects per device.</p>
<p>Be sure you call the <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">setup()</a> and <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">loop()</a> methods of the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> object! </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="afad2003d2b92d21f56faf48dbec790c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad2003d2b92d21f56faf48dbec790c5">&#9670;&nbsp;</a></span>WakeReason</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5">AB1805::WakeReason</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return codes for <a class="el" href="class_a_b1805.html#a8da821fd718c0c72af2d2849ffe23559" title="Gets the reason the device was reset or woken. For example, TIMER, ALARM, WATCHDOG,...">getWakeReason()</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afad2003d2b92d21f56faf48dbec790c5a696b031073e74bf2cb98e5ef201d4aa3"></a>UNKNOWN&#160;</td><td class="fielddoc"><p>Wake reason is not know (may be from something other than RTC) </p>
</td></tr>
<tr><td class="fieldname"><a id="afad2003d2b92d21f56faf48dbec790c5ae8e0182f554bb505df81621069717de7"></a>WATCHDOG&#160;</td><td class="fielddoc"><p>Watchdog trigged reset. </p>
</td></tr>
<tr><td class="fieldname"><a id="afad2003d2b92d21f56faf48dbec790c5a7490d3d9f861bacc8815171784f79d7b"></a>DEEP_POWER_DOWN&#160;</td><td class="fielddoc"><p>The <a class="el" href="class_a_b1805.html#a477a5b2fc850d1a6d3e019af4e960da0" title="Enters deep power down reset mode, using the EN pin.">deepPowerDown()</a> function was used (RTC was in sleep mode) </p>
</td></tr>
<tr><td class="fieldname"><a id="afad2003d2b92d21f56faf48dbec790c5ae41eb276fb434d351ce14a486dedf66b"></a>COUNTDOWN_TIMER&#160;</td><td class="fielddoc"><p>The <a class="el" href="class_a_b1805.html#a8c6cb815e28b2146cb88e999b78da16e" title="Interrupt at a time in the future, either in minutes or seconds.">interruptCountdownTimer()</a> was used. </p>
</td></tr>
<tr><td class="fieldname"><a id="afad2003d2b92d21f56faf48dbec790c5a9de6d0a670ae5a0dee31a6318aa00e8d"></a>ALARM&#160;</td><td class="fielddoc"><p>RTC clock alarm (periodic or single) trigged wake. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5e32299bbe31841fcbeb73d2175ccb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e32299bbe31841fcbeb73d2175ccb65">&#9670;&nbsp;</a></span>AB1805()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AB1805::AB1805 </td>
          <td>(</td>
          <td class="paramtype">TwoWire &amp;&#160;</td>
          <td class="paramname"><em>wire</em> = <code>Wire</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>i2cAddr</em> = <code>0x69</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> driver object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wire</td><td>The I2C (TwoWire) inteface to use. Usually <code>Wire</code>.</td></tr>
    <tr><td class="paramname">i2cAddr</td><td>The I2C address. This is always 0x69 on the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> as the address is not configurable. <br  />
</td></tr>
  </table>
  </dd>
</dl>
<p>You typically allocate one of these objects as a global variable as a singleton. You can only have one of these objects per device. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af69e97a9fd017318a5b88b55f7193f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69e97a9fd017318a5b88b55f7193f0d">&#9670;&nbsp;</a></span>checkVBAT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::checkVBAT </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>isAbove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks VBAT status. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mask</td><td>Either REG_ASTAT_BBOD (compare againt BREF) or REG_ASTAT_BMIN (compare against minimum, 1.2V)</td></tr>
    <tr><td class="paramname">isAbove</td><td>True if VBAT is above the specified voltage, or false if not</td></tr>
  </table>
  </dd>
</dl>
<p>This function will check if trickle charging is enabled first. If enabled, it will be turned off, the value checked, then turned back on again. </p>

</div>
</div>
<a id="a119407078df15ab7036dab66402c0ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a119407078df15ab7036dab66402c0ee3">&#9670;&nbsp;</a></span>clearRegisterBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::clearRegisterBit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear a bit in a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>The address of the register to read/write</td></tr>
    <tr><td class="paramname">bitMask</td><td>The bit mask to clear. This has a 1 bit in the bit you want to clear, and will typically only have one bit set, though you can clear multiple bits at the same time with this function.</td></tr>
    <tr><td class="paramname">lock</td><td>Whether to lock the I2C bus, the default is true. You pass false if you are grouping together functions in a single lock, for example doing a read/modify/write cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>The bit is cleared only if set. If the bit(s) are already cleared, then only the read is done, and the write is skipped. A read is always done.</p>
<p>If lock is true, then the lock surround both the read and write so the entire operation is atomic. </p>

</div>
</div>
<a id="a5ea444cda68d3ffbda6de2d8bb44a8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ea444cda68d3ffbda6de2d8bb44a8d1">&#9670;&nbsp;</a></span>clearRepeatingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::clearRepeatingInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear repeating interrupt set with <code><a class="el" href="class_a_b1805.html#a95deb0ee00170824c8a1df71207a3d90" title="Set a repeating interrupt.">repeatingInterrupt()</a></code>. </p>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs. </dd></dl>

</div>
</div>
<a id="a477a5b2fc850d1a6d3e019af4e960da0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477a5b2fc850d1a6d3e019af4e960da0">&#9670;&nbsp;</a></span>deepPowerDown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::deepPowerDown </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seconds</em> = <code>30</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters deep power down reset mode, using the EN pin. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>number of seconds to power down. Must be 0 &lt; seconds &lt;= 255. The default is 30 seconds. If time-sensitive, 10 seconds is probably sufficient.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>This method powers down the MCU and cellular modem by using a combination of the EN and RST pins. This super-reset is similar to what would happen if you disconnected the battery.</p>
<p>It assumes that EN is connected to /nIRQ2 (PSW) on the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> using an N-channel MOSFET and RST is connected to /RESET on the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>.</p>
<p>After the deep reset finishes, the device will reboot and go back through <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">setup()</a> again. Calling getWakeReset() will return the reason <code>DEEP_POWER_DOWN</code>.</p>
<p>This works even if the RTC has not been set yet. </p>

</div>
</div>
<a id="aab0527f95937cc13acfce4e84b708d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0527f95937cc13acfce4e84b708d32">&#9670;&nbsp;</a></span>detectChip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::detectChip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the I2C bus to make sure there is an <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> present. </p>
<p>This is called during <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">AB1805::setup()</a>. </p>

</div>
</div>
<a id="a791920f84716d1bb3eaa529857eb8bab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791920f84716d1bb3eaa529857eb8bab">&#9670;&nbsp;</a></span>eraseRam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::eraseRam </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Erases the RTC RAM to 0x00 values. </p>
<p>Erases the RTC RAM to 0x00.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lock</td><td>Whether to lock the I2C bus, the default is true. You pass false if you are grouping together functions in a single lock, for example doing a read/modify/write cycle. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43558bc27b5020ece8d69597d61fd81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43558bc27b5020ece8d69597d61fd81b">&#9670;&nbsp;</a></span>get()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; AB1805::get </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ramAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read from RTC RAM using EEPROM-style API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramAddr</td><td>The address in the RTC RAM to read from</td></tr>
    <tr><td class="paramname">t</td><td>The variable to read to. This must be a simple type (bool, int, float, etc.) or struct. It cannot save a c-string (const char *), String, or other class. You typically cannot get any pointers or structs containing pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afc2ccbed689ea8aa0197705dfa9696ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2ccbed689ea8aa0197705dfa9696ec">&#9670;&nbsp;</a></span>getRtcAsTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::getRtcAsTime </td>
          <td>(</td>
          <td class="paramtype">time_t &amp;&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time from the RTC as a time_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>Filled in with the number of second since January 1, 1970 UTC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>The time value is basically the same as what would be returned from <code>Time.now()</code> except it's retrieved from the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> RTC instead of the system. However both should approximately equal to each other. </p>

</div>
</div>
<a id="a92a69833d9a015dce8e7f5bbb55a99fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a69833d9a015dce8e7f5bbb55a99fc">&#9670;&nbsp;</a></span>getRtcAsTm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::getRtcAsTm </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the time from the RTC as a struct tm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>pointer to struct tm. Filled in with the current time, UTC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>Note: This uses mktime, which technically is local time, not UTC. However, the standard library is set at UTC as the local time. Using Time.zone() changes the timezone in the <code>Time</code> class but does not modifying the underling standard C library, so mktime should always be UTC.</p>
<p>The fields of the timeptr are:</p><ul>
<li>tm_sec seconds after the minute 0-61 (usually 0-59)</li>
<li>tm_min minutes after the hour 0-59</li>
<li>tm_hour hours since midnight 0-23</li>
<li>tm_mday day of the month 1-31</li>
<li>tm_mon months since January 0-11 (not 1-12!)</li>
<li>tm_year years since 1900 (note: 2020 = 120)</li>
<li>tm_wday days since Sunday 0-6 </li>
</ul>

</div>
</div>
<a id="a8da821fd718c0c72af2d2849ffe23559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da821fd718c0c72af2d2849ffe23559">&#9670;&nbsp;</a></span>getWakeReason()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_b1805.html#afad2003d2b92d21f56faf48dbec790c5">WakeReason</a> AB1805::getWakeReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the reason the device was reset or woken. For example, TIMER, ALARM, WATCHDOG, etc. </p>
<p>This is set during <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">AB1805::setup()</a> automatically (for HIBERNATE, ULP, and SLEEP_MODE_DEEP) as well as normal reset, however if you are using STOP mode sleep, you must call <code><a class="el" href="class_a_b1805.html#afd13ad2d31fb669977142b39dca9e37e" title="Update the wake reason. This is needed after STOP mode System.sleep()">updateWakeReason()</a></code> after System.sleep() returns to update the wake reason. </p>

</div>
</div>
<a id="a5d085590f8fc332808d3c8aa58c8e17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d085590f8fc332808d3c8aa58c8e17c">&#9670;&nbsp;</a></span>interruptAtTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::interruptAtTime </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>time</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an interrupt at a time in the future using a time_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The number of second after January 1, 1970 UTC.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>This causes an interrupt on FOUT/nIRQ in the future. It will execute once. This can only be done if the RTC has been programmed with the current time, which it normally gets from the cloud at startup.</p>
<p>There can only be one interrupt set. Setting at one-time or repeating interrupt removes any previously set interrupt time. </p>

</div>
</div>
<a id="a7cf74b3ae927cccbba8025af60b111ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf74b3ae927cccbba8025af60b111ac">&#9670;&nbsp;</a></span>interruptAtTm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::interruptAtTm </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set an interrupt at a time in the future using a struct tm *. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>pointer to struct tm. This specifies the time (UTC).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>This causes an interrupt on FOUT/nIRQ in the future. It will execute once. This can only be done if the RTC has been programmed with the current time, which it normally gets from the cloud at startup.</p>
<p>Only the tm_sec, tm_min, tm_hour, tm_mday, tm_mon, and tm_year are used. The tm_wday field is ignored. Note that tm_mon is 0-11, not 1-12.</p>
<p>There can only be one interrupt set. Setting at one-time or repeating interrupt removes any previously set interrupt time.</p>
<p>The fields of the timeptr are:</p><ul>
<li>tm_sec seconds after the minute 0-61 (usually 0-59)</li>
<li>tm_min minutes after the hour 0-59</li>
<li>tm_hour hours since midnight 0-23</li>
<li>tm_mday day of the month 1-31</li>
<li>tm_mon months since January 0-11 (not 1-12!)</li>
<li>tm_year years since 1900 (note: 2020 = 120)</li>
<li>tm_wday days since Sunday 0-6 </li>
</ul>

</div>
</div>
<a id="a8c6cb815e28b2146cb88e999b78da16e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6cb815e28b2146cb88e999b78da16e">&#9670;&nbsp;</a></span>interruptCountdownTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::interruptCountdownTimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minutes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt at a time in the future, either in minutes or seconds. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value in seconds or minutes. Must be 0 &lt; value &lt;= 255!</td></tr>
    <tr><td class="paramname">minutes</td><td>True if minutes, false if seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>The countdown timer works even if the RTC has not been set yet, but is more limited in range (maximum: 255 minutes). </p>

</div>
</div>
<a id="a5c8d879652bb66cfd0b8235682c9a1e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c8d879652bb66cfd0b8235682c9a1e9">&#9670;&nbsp;</a></span>isBitClear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::isBitClear </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a bit in a register is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to read from (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">bitMask</td><td>Mask to check. Note that the bitMask should have a 1 bit where you are checking for a 0 bit! Normally there is only one bit set in bitMask.</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the register could be read and the bit is 0, otherwise false. </dd></dl>

</div>
</div>
<a id="ac42f7fb5588a7c136a79dcdf987d8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42f7fb5588a7c136a79dcdf987d8621">&#9670;&nbsp;</a></span>isBitSet()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::isBitSet </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a bit in a register is 1. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to read from (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">bitMask</td><td>Mask to check. The bitMask should have a 1 bit where you are checking for a 1 bit. Normally there is only one bit set in bitMask.</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the register could be read and the bit is 1, otherwise false. </dd></dl>

</div>
</div>
<a id="a1df1720dee0e46d3db1a7278f445203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df1720dee0e46d3db1a7278f445203f">&#9670;&nbsp;</a></span>isRTCSet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::isRTCSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the RTC has been set. </p>
<p>On cold power-up before cloud connecting, this will be false. Note that </p>

</div>
</div>
<a id="ac9ae3d3f3a045119004dad192a373fd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9ae3d3f3a045119004dad192a373fd9">&#9670;&nbsp;</a></span>isVBATAboveBREF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::isVBATAboveBREF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if VBAT input is above BREF voltage. </p>
<p>The power-up default for BREF is 1.4V (<code>REG_BREF_CTRL_14_16</code>), so this provides some additional margin over the minimum voltage (1.2V). BREF can be changed to check for higher voltages (fully charged, for example) but it takes several seconds for the values to settle after making a change, so you don't want to change it too often.</p>
<p>This function will check if trickle charging is enabled first. If enabled, it will be turned off, the value checked, then turned back on again. </p>

</div>
</div>
<a id="ab4fb028700fb69023a87f9cc72abab11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4fb028700fb69023a87f9cc72abab11">&#9670;&nbsp;</a></span>isVBATAboveMin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::isVBATAboveMin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if VBAT input is above minimum operating voltage (1.2V) </p>
<p>This function will check if trickle charging is enabled first. If enabled, it will be turned off, the value checked, then turned back on again. </p>

</div>
</div>
<a id="ab240035c2ff0fa3762a04626e3b463e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab240035c2ff0fa3762a04626e3b463e3">&#9670;&nbsp;</a></span>maskRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::maskRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>andValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>orValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte) with masking of existing value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to read from and write to (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">andValue</td><td>The existing register values is logically ANDed with this value</td></tr>
    <tr><td class="paramname">orValue</td><td>This value is logically ORed with this value before storing</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on error</dd></dl>
<p>If lock is true then the lock surrounds both the read and write, so the operation is atomic.</p>
<p>If the value is unchanged after the andValue and orValue is applied, the write is skipped. The read is always done. </p>

</div>
</div>
<a id="a7abf2aef84d17b61641c37893d4275f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7abf2aef84d17b61641c37893d4275f5">&#9670;&nbsp;</a></span>put()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; AB1805::put </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ramAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write from RTC RAM using EEPROM-style API. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramAddr</td><td>The address in the RTC RAM to write to</td></tr>
    <tr><td class="paramname">t</td><td>The variable to write from. t is not modified. This must be a simple type (bool, int, float, etc.) or struct. It cannot save a c-string (const char *), String, or other class. You typically cannot save any pointers or structs containing pointers. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aabf727cf88995b19371b15dbe4dd3ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabf727cf88995b19371b15dbe4dd3ac0">&#9670;&nbsp;</a></span>readRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::readRam </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ramAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level read call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramAddr</td><td>The address in the RTC RAM to read from</td></tr>
    <tr><td class="paramname">data</td><td>The buffer to read into</td></tr>
    <tr><td class="paramname">dataLen</td><td>The number of bytes to read</td></tr>
    <tr><td class="paramname">lock</td><td>Whether to lock the I2C bus, the default is true. You pass false if you are grouping together functions in a single lock, for example doing a read/modify/write cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>The dataLen can be larger than the maximum I2C read. Multiple reads will be done if necessary. However do not read past the end of RAM (address 255).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramAddr</td><td>The address in the RTC RAM to read from</td></tr>
    <tr><td class="paramname">data</td><td>The buffer to read into</td></tr>
    <tr><td class="paramname">dataLen</td><td>The number of bytes to read</td></tr>
  </table>
  </dd>
</dl>
<p>The dataLen can be larger than the maximum I2C read. Multiple reads will be done if necessary. </p>

</div>
</div>
<a id="a7d6170ce3c6c9427df4972d2a5947b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6170ce3c6c9427df4972d2a5947b51">&#9670;&nbsp;</a></span>readRegister() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t AB1805::readRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte) and returns it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to read from (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the register or 0x00 if it could not be read.</dd></dl>
<p>There is an overload that takes a uint8_t &amp;value parameter which is generally better because you can tell the difference between a value of 0 and a failure (false is returned). </p>

</div>
</div>
<a id="af14273577e543d6998d721a47edb4d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af14273577e543d6998d721a47edb4d15">&#9670;&nbsp;</a></span>readRegister() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::readRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to read from (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">value</td><td>Filled in with the value from the register</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on error</dd></dl>
<p>There is also an overload that returns value instead of passing it by reference. </p>

</div>
</div>
<a id="a474382cce9b4727690059d0f46a0f1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474382cce9b4727690059d0f46a0f1ca">&#9670;&nbsp;</a></span>readRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::readRegisters </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads sequential registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to start reading from (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">array</td><td>Array of uint8_t values, filled in by this call</td></tr>
    <tr><td class="paramname">num</td><td>Number of registers to read</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<p>Reads a number of registers at once. This is done when reading the RTC value so it's atomic (counters will not be incremented in the middle of a read). Also used for reading the device RAM.</p>
<p>Do not read past address 0xff. </p>

</div>
</div>
<a id="afd515347c26486819bebaa92606bff06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd515347c26486819bebaa92606bff06">&#9670;&nbsp;</a></span>registersToTm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AB1805::registersToTm </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeYear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert register values to a struct tm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">array</td><td>Pointer to an array of values from the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>. Point to the seconds (not hundredths).</td></tr>
    <tr><td class="paramname">timeptr</td><td>Pointer to a struct tm to hold the converted time</td></tr>
    <tr><td class="paramname">includeYear</td><td>True if this is the the year should be included (time setting), or false if the year should not be included (alarm setting). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95deb0ee00170824c8a1df71207a3d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95deb0ee00170824c8a1df71207a3d90">&#9670;&nbsp;</a></span>repeatingInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::repeatingInterrupt </td>
          <td>(</td>
          <td class="paramtype">struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>rptValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set a repeating interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>pointer to struct tm. This specifies the time (UTC).</td></tr>
    <tr><td class="paramname">rptValue</td><td>a constant for which fields of timeptr are used.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>This causes an interrupt on FOUT/nIRQ in the future, repeating. This can only be done if the RTC has been programmed with the current time, which it normally gets from the cloud at startup.</p>
<ul>
<li><code>REG_TIMER_CTRL_RPT_SEC</code> tm_sec matches (once per minute)</li>
<li><code>REG_TIMER_CTRL_RPT_MIN</code> tm_sec, tm_min match (once per hour)</li>
<li><code>REG_TIMER_CTRL_RPT_HOUR</code> tm_sec, tm_min, tm_hour match (once per day)</li>
<li><code>REG_TIMER_CTRL_RPT_WKDY</code> tm_sec, tm_min, tm_hour, tm_wday match (once per week)</li>
<li><code>REG_TIMER_CTRL_RPT_DATE</code> tm_sec, tm_min, tm_hour, tm_mday match (once per month)</li>
<li><code>REG_TIMER_CTRL_RPT_MON</code> tm_sec, tm_min, tm_hour, tm_mday, tm_mon match (once per year)</li>
</ul>
<p>Note that tm_mon (month) is 0 - 11, not 1 - 12!</p>
<p>There can only be one interrupt set. Setting at one-time or repeating interrupt removes any previously set interrupt time.</p>
<p>If you reset the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> configuration using <code><a class="el" href="class_a_b1805.html#aee9d908319670a76d876763886ffd939" title="Resets the configuration of the AB1805 to default settings.">resetConfig()</a></code>, the repeating timer will be cleared, unless you add the <code><a class="el" href="class_a_b1805.html#a74ff2c5a015e40caa05f8ab3bf17f015" title="When resetting registers, leave repeating timer settings intact.">AB1805::RESET_PRESERVE_REPEATING_TIMER</a></code> parameter to preserve it.</p>
<p>The fields of the timeptr are:</p><ul>
<li>tm_sec seconds after the minute 0-61 (usually 0-59)</li>
<li>tm_min minutes after the hour 0-59</li>
<li>tm_hour hours since midnight 0-23</li>
<li>tm_mday day of the month 1-31</li>
<li>tm_mon months since January 0-11 (not 1-12!)</li>
<li>tm_year years since 1900 (note: 2020 = 120)</li>
<li>tm_wday days since Sunday 0-6 </li>
</ul>

</div>
</div>
<a id="aee9d908319670a76d876763886ffd939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee9d908319670a76d876763886ffd939">&#9670;&nbsp;</a></span>resetConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::resetConfig </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the configuration of the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> to default settings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>flags to customize reset behavior (default: 0)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>The only exception currently defined is <code><a class="el" href="class_a_b1805.html#a74ff2c5a015e40caa05f8ab3bf17f015" title="When resetting registers, leave repeating timer settings intact.">AB1805::RESET_PRESERVE_REPEATING_TIMER</a></code> that keeps repeating timers programmed when resetting configuration. </p>

</div>
</div>
<a id="a78f9d71f35eaac964ee22e06d7ec505e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f9d71f35eaac964ee22e06d7ec505e">&#9670;&nbsp;</a></span>resumeWDT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::resumeWDT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resumes watchdog with same settings as before. </p>
<p>This is useful after returning from <code>System.sleep()</code> in STOP or ULTRA_LOW_POWER sleep modes where executinon continues. You may also want to call <code><a class="el" href="class_a_b1805.html#afd13ad2d31fb669977142b39dca9e37e" title="Update the wake reason. This is needed after STOP mode System.sleep()">updateWakeReason()</a></code>.</p>
<p>It's safe to call <a class="el" href="class_a_b1805.html#a78f9d71f35eaac964ee22e06d7ec505e" title="Resumes watchdog with same settings as before.">resumeWDT()</a> even if the WDT has never been set, it does nothing in this case, leaving the watchdog off. </p>

</div>
</div>
<a id="a6f3de973020fef6592646b0c948923bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f3de973020fef6592646b0c948923bc">&#9670;&nbsp;</a></span>setCountdownTimer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setCountdownTimer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>minutes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Used internally by interruptCountdownTimer and deepPowerDown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value in seconds or minutes. Must be 0 &lt; value &lt;= 255!</td></tr>
    <tr><td class="paramname">minutes</td><td>True if minutes, false if seconds</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>The countdown timer works even if the RTC has not been set yet, but is more limited in range (maximum: 255 minutes). </p>

</div>
</div>
<a id="a3d21a24845cb60124691b14b17da84c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d21a24845cb60124691b14b17da84c4">&#9670;&nbsp;</a></span>setRegisterBit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setRegisterBit </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bitMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a bit in a register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>The address of the register to read/write</td></tr>
    <tr><td class="paramname">bitMask</td><td>The bit mask to set. This has a 1 bit in the bit you want to set, and will typically only have one bit set, though you can set multiple bits at the same time with this function.</td></tr>
    <tr><td class="paramname">lock</td><td>Whether to lock the I2C bus, the default is true. You pass false if you are grouping together functions in a single lock, for example doing a read/modify/write cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>The bit is set only if cleared (0). If the bit(s) are already set, then only the read is done, and the write is skipped. A read is always done.</p>
<p>If lock is true, then the lock surround both the read and write so the entire operation is atomic. </p>

</div>
</div>
<a id="a2655a5e1928d658b443a45c7f10a026f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2655a5e1928d658b443a45c7f10a026f">&#9670;&nbsp;</a></span>setRtcFromSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setRtcFromSystem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the RTC from the system clock. </p>
<p>This is called automatically from <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">AB1805::loop()</a> when the time is updated from the cloud. You normally don't need to call this yourself. </p>

</div>
</div>
<a id="a3d6f9310f9d60c9c1e834cbcff5ae8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6f9310f9d60c9c1e834cbcff5ae8c4">&#9670;&nbsp;</a></span>setRtcFromTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setRtcFromTime </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RTC from a time_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">time</td><td>The time (in seconds since January 1, 1970, UNIX epoch), UTC.</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<p>This is called automatically from <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">AB1805::loop()</a> when the time is updated from the cloud. You normally don't need to call this yourself. You might call this if you are also getting time from an external source like a GPS. </p>

</div>
</div>
<a id="a681f919fa1d706383d1b8a4ba68703fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a681f919fa1d706383d1b8a4ba68703fc">&#9670;&nbsp;</a></span>setRtcFromTm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setRtcFromTm </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the RTC from a time_t. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>A struct tm specifying the time.</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<p>The following fields are required:</p><ul>
<li>tm_sec seconds after the minute 0-61 (usually 0-59)</li>
<li>tm_min minutes after the hour 0-59</li>
<li>tm_hour hours since midnight 0-23</li>
<li>tm_mday day of the month 1-31</li>
<li>tm_mon months since January 0-11 (not 1-12!)</li>
<li>tm_year years since 1900 (note: 2020 = 120)</li>
<li>tm_wday days since Sunday 0-6</li>
</ul>
<p>Note that you must include tm_wday and 0 = Sunday, 1 = Monday, ... Month of year is 0 - 11, NOT 1 - 12! Year is years since 1900, so 2020 has 120 in the tm_year field!</p>
<p>This is called automatically from <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">AB1805::loop()</a> when the time is updated from the cloud. You normally don't need to call this yourself. You might call this if you are also getting time from an external source like a GPS. </p>

</div>
</div>
<a id="afa233adaafd65b19876568699dccd762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa233adaafd65b19876568699dccd762">&#9670;&nbsp;</a></span>setTrickle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setTrickle </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>diodeAndRout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable trickle charging mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">diodeAndRout</td><td>Pass 0 to disable the trickle charger or one diode constant and one rout constant below.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false if an error occurs.</dd></dl>
<p>Diode settings determine the voltage applied to the supercap or battery in trickle charge mode. This is from VCC, which is generally 3V3, so this will be a voltage of 2.7V or 3.0V. This makes the trickle charger compatible with a wider variety of supercaps.</p>
<ul>
<li><code>REG_TRICKLE_DIODE_0_6</code> diode 0.6V drop</li>
<li><code>REG_TRICKLE_DIODE_0_3</code> diode 0.3V drop</li>
</ul>
<p>The ROUT setting determines the series resistor to the supercap. This determines charging speed.</p>
<ul>
<li><code>REG_TRICKLE_ROUT_11K</code> rout 11K</li>
<li><code>REG_TRICKLE_ROUT_6K</code> rout 6K</li>
<li><code>REG_TRICKLE_ROUT_3K</code> rout 3K</li>
</ul>
<p>The sample design includes an additional 1.5K series resistance using an external resistor, so applying 3K results in an actual series resistance of 4.5K. </p>

</div>
</div>
<a id="a6b597349a25f03f380a3261a5b9f0045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b597349a25f03f380a3261a5b9f0045">&#9670;&nbsp;</a></span>setup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AB1805::setup </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>callBegin</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call this from main <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">setup()</a> to initialize the library. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callBegin</td><td>Whether to call wire.begin(). Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a889f51cd5a025428c683b2842d9d52ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889f51cd5a025428c683b2842d9d52ff">&#9670;&nbsp;</a></span>setWDT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::setWDT </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>seconds</em> = <code>-1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set or reset the watchdog timer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seconds</td><td>Duration of watchdog timer or -1 to tickle/pet/service the watchdog.</td></tr>
  </table>
  </dd>
</dl>
<p>Minimum is 4 and maximum is 124 seconds. 0 disables the watchdog timer. The constant <code>WATCHDOG_MAX_SECONDS</code> is 124 and is a good choice. -1 resets the timer to the previous setting and is used to tickle/pet/service the watchdog timer. This is done from <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">AB1805::loop()</a>.</p>
<p>Periodically servicing the watchdog (-1) is handled automatically in <a class="el" href="class_a_b1805.html#aa8640af3fba5486740b2fc5acf7b1672" title="Call this from main loop(). Should be called on every call to loop().">AB1805::loop()</a> so you normally don't need to worry about it. Since it requires an I2C transaction you probably don't want to call it on every loop. </p>

</div>
</div>
<a id="a7c75e4e820a2715c734eec1aa1864c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c75e4e820a2715c734eec1aa1864c28">&#9670;&nbsp;</a></span>stopWDT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::stopWDT </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stops the watchdog timer. Useful before entering sleep mode. </p>
<p>This is done automatically right before reset (using the reset system event) so the watchdog won't trigger during a firmware update. </p>

</div>
</div>
<a id="a537c9642ad784fbd52423c3d0e074ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537c9642ad784fbd52423c3d0e074ab1">&#9670;&nbsp;</a></span>systemEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AB1805::systemEvent </td>
          <td>(</td>
          <td class="paramtype">system_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Internal function used to handle system events. </p>
<p>We currently only handle the reset event to disable the WDT before reset so it won't trigger during a OTA firmware update. </p>

</div>
</div>
<a id="a6b079ff9593ced5da34f73111e72264e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b079ff9593ced5da34f73111e72264e">&#9670;&nbsp;</a></span>systemEventStatic()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AB1805::systemEventStatic </td>
          <td>(</td>
          <td class="paramtype">system_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>param</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Static function passed to System.on. </p>
<p><a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> is a singleton so <a class="el" href="class_a_b1805.html#a93d2b1f320a49fe156b0524b37e7a134" title="Singleton for AB1805. Set in constructor.">AB1805::instance</a> is used to find the instance pointer. </p>

</div>
</div>
<a id="a6673da5d88733e6457f161c9a17f2997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6673da5d88733e6457f161c9a17f2997">&#9670;&nbsp;</a></span>tmToRegisters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void AB1805::tmToRegisters </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>includeYear</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a struct tm to register values for the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeptr</td><td>Pointer to a struct tm with the values to convert from</td></tr>
    <tr><td class="paramname">array</td><td>Array of uint8_t to store the values to. This must be at least 6 bytes if includeYear is false or 7 if true. This points to the seconds field, not the hundredths field!</td></tr>
    <tr><td class="paramname">includeYear</td><td>True if this is the the year should be included (time setting), or false if the year should not be included (alarm setting).</td></tr>
  </table>
  </dd>
</dl>
<p>Note: Does not include the hundredths are struct tm doesn't include fractional seconds. </p>

</div>
</div>
<a id="ae0d37f7e9b4bed655065e66cc0fe9bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d37f7e9b4bed655065e66cc0fe9bd1">&#9670;&nbsp;</a></span>tmToString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">String AB1805::tmToString </td>
          <td>(</td>
          <td class="paramtype">const struct tm *&#160;</td>
          <td class="paramname"><em>timeptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Utility function to convert a struct tm * to a readable string. </p>
<dl class="section return"><dt>Returns</dt><dd>String in the format of "yyyy-mm-dd hh:mm:ss". </dd></dl>

</div>
</div>
<a id="afd13ad2d31fb669977142b39dca9e37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd13ad2d31fb669977142b39dca9e37e">&#9670;&nbsp;</a></span>updateWakeReason()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::updateWakeReason </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the wake reason. This is needed after STOP mode System.sleep() </p>
<p>The wake reason is set during <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">AB1805::setup()</a> automatically (for HIBERNATE, ULP, and SLEEP_MODE_DEEP) as well as normal reset, however if you are using STOP mode sleep, you must call <code><a class="el" href="class_a_b1805.html#afd13ad2d31fb669977142b39dca9e37e" title="Update the wake reason. This is needed after STOP mode System.sleep()">updateWakeReason()</a></code> after System.sleep() returns to update the wake reason. </p>

</div>
</div>
<a id="a2d8b06308fed7a847d07ec29e2a3e6c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8b06308fed7a847d07ec29e2a3e6c4">&#9670;&nbsp;</a></span>usingRCOscillator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::usingRCOscillator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check oscillator. </p>
<dl class="section return"><dt>Returns</dt><dd>true if RC oscillator is being used, false if XT (crystal) </dd></dl>

</div>
</div>
<a id="a05b9c585aea461af5e0ff80da49f4acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b9c585aea461af5e0ff80da49f4acc">&#9670;&nbsp;</a></span>withFOUT()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_a_b1805.html">AB1805</a>&amp; AB1805::withFOUT </td>
          <td>(</td>
          <td class="paramtype">pin_t&#160;</td>
          <td class="paramname"><em>pin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call this before <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">AB1805::setup()</a> to specify the pin connected to FOUT/nIRQ. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pin</td><td>The pin (like <code>D8</code>) that is connected to FOUT.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a>&amp; so you can chain the withXXX() calls, fluent-style- then call the <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">AB1805::setup()</a> method.</dd></dl>
<p>This must be called before <a class="el" href="class_a_b1805.html#a6b597349a25f03f380a3261a5b9f0045" title="Call this from main setup() to initialize the library.">setup()</a>. Default is <code>PIN_INVALID</code> which signifies that FOUT is not connected.</p>
<p>This is used during chip detection as FOUT goes high after the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> is initialized. While FOUT is low, the I2C interface is not yet ready.</p>
<p>The FOUT/nIRQ pin is also used for one-time and periodic interrupts. </p>

</div>
</div>
<a id="ac86b7c3c3649185301c4a42a2a3465cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86b7c3c3649185301c4a42a2a3465cd">&#9670;&nbsp;</a></span>writeRam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::writeRam </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ramAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dataLen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Low-level write call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramAddr</td><td>The address in the RTC RAM to write to</td></tr>
    <tr><td class="paramname">data</td><td>The buffer containing the data to write</td></tr>
    <tr><td class="paramname">dataLen</td><td>The number of bytes to write</td></tr>
    <tr><td class="paramname">lock</td><td>Whether to lock the I2C bus, the default is true. You pass false if you are grouping together functions in a single lock, for example doing a read/modify/write cycle.</td></tr>
  </table>
  </dd>
</dl>
<p>The dataLen can be larger than the maximum I2C write. Multiple writes will be done if necessary. However do not read past the end of RAM (address 255).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ramAddr</td><td>The address in the RTC RAM to write to</td></tr>
    <tr><td class="paramname">data</td><td>The buffer containing the data to write</td></tr>
    <tr><td class="paramname">dataLen</td><td>The number of bytes to write</td></tr>
  </table>
  </dd>
</dl>
<p>The dataLen can be larger than the maximum I2C write. Multiple writes will be done if necessary. </p>

</div>
</div>
<a id="a154f52145b4e0344d283aa203feab2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154f52145b4e0344d283aa203feab2b4">&#9670;&nbsp;</a></span>writeRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::writeRegister </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> register (single byte) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to write to (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">value</td><td>This value is written to the register</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on error </dd></dl>

</div>
</div>
<a id="ac83d38509c2fcf4f2a397607d6ee7014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83d38509c2fcf4f2a397607d6ee7014">&#9670;&nbsp;</a></span>writeRegisters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AB1805::writeRegisters </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>regAddr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>lock</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes sequential <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">regAddr</td><td>Register address to start writing to (0x00 - 0xff)</td></tr>
    <tr><td class="paramname">array</td><td>Array of uint8_t values to write</td></tr>
    <tr><td class="paramname">num</td><td>Number of registers to write</td></tr>
    <tr><td class="paramname">lock</td><td>Lock the I2C bus. Default = true. Pass false if surrounding a block of related calls with a wire.lock() and wire.unlock() so the block cannot be interrupted with other I2C operations.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success or false on error</dd></dl>
<p>Do not write past address 0xff. </p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a id="a5ce37ba1f55c8661c4fafd41632369b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce37ba1f55c8661c4fafd41632369b6">&#9670;&nbsp;</a></span>foutPin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pin_t AB1805::foutPin = PIN_INVALID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Which GPIO is connected to FOUT/nIRQ. </p>
<p>Set to PIN_INVALID if not connected.</p>
<p>This is used for interrupts, and also to detect if the <a class="el" href="class_a_b1805.html" title="Class for using the AB1805/AM1805 RTC/watchdog chip.">AB1805</a> is alive, during <a class="el" href="class_a_b1805.html#aab0527f95937cc13acfce4e84b708d32" title="Checks the I2C bus to make sure there is an AB1805 present.">detectChip()</a>. If not connected, then only I2C is used to detect the chip. </p>

</div>
</div>
<a id="a6592c54ae4a8eba3b23651b7d2151546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6592c54ae4a8eba3b23651b7d2151546">&#9670;&nbsp;</a></span>watchdogSecs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int AB1805::watchdogSecs = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Watchdog period in seconds (1 &lt;= watchdogSecs &lt;= 124) or 0 for disabled. </p>
<p>This is used so setWDT(-1) can restore the previous value. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_a_b1805___r_k_8h_source.html">AB1805_RK.h</a></li>
<li>src/AB1805_RK.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
